####################################################################################################
###                                           GIT
###                             DISTRIBUTED VERSION CONTROL SYSTEM
###                     git clone https://github.com/locktree/testing
####################################################################################################
-Nearly Every Operation is Local:
    -Operations are usually very fast
    -You can work offline, while for example on a plane
    -You can be sloppy and clean up after yourself before pushing your changes
-Has a staging area, so you can add only some of your changes and commit when ready.
-Commits referred to from your reflog are considered reachable
-Git is a content-addressable filesystem: It means that at the core of Git is a simple key-value data store.
-man git-config
-prune = snoeien
-detached = vrijstaande
.gitkeep   ==> because you cannot add an empty directory (NOT OFFICAL DOCUMENTED)
####################################################################################################
##                                FUNDAMENTAL
####################################################################################################
git init [project]                Init local repo
git clone [url]                   Clone existing repo (SSH/GIT/HTTPS)
git clone --recursive             Initialize and update each submodule
git clone -b [branch] [url]       Clone a specific branch
git config                        Configure repo
git config --list                 List all configurations(local/global/system)
git status                        Show status of working tree (staged/unstaged/untracked)
                                       ??        = Untracked
                                       M(yellow) = Modified
                                       M(green)  = Staged
                                       A         = New file added to staging area
----------------------------------------------------------------------------------------------------
-git clone git://repohost/project1.git
 ==> 1. Creates a new remote-tracking branch named origin/master
     2. Copies the remote repository from git://repohost/project1.git to the new remote-tracking branch named origin/master.
-When you clone a repository, it generally automatically creates a master branch that tracks origin/master.
####################################################################################################
##                                ADD
####################################################################################################
git add [file]                    Stage file. (creates hash, compresses the file and adds the
                                  compressed object to the object store)
git add -p [file]                 Stages in patches (to partial commit code)
git add -f [file]                 Stage file if file is in the gitignore
git add -A or -all                Stages all
####################################################################################################
##                                REMOVE
####################################################################################################
git rm [file]                     Remove file from working directory and stages the deletion
git rm --cached/staged [file]     Remove file from staging but keep in working
git rm -r [directory]             Remove recursively
####################################################################################################
##                                MOVE
####################################################################################################
git mv [file] [file]              Changes the file name and stages. Index is updated, not committed
####################################################################################################
##                                DIFF
####################################################################################################
git diff                          Diff workspace and stage/index
git diff --cached/staged          Diff stage/index and HEAD(current commit)
git diff HEAD                     Diff workspace and the HEAD(current commit)
----------------------------------------------------------------------------------------------------
git diff [c1] [c2]                Diff two commit ids. If second item omitted, diff agains HEAD
git diff [b1] [b2]                Diff two branches.   If second item omitted, diff agains HEAD
git diff [s1] [s2]                Diff two stashes.    If second item omitted, diff agains HEAD
git diff HEAD^ HEAD               Diff last commit and previous commit
----------------------------------------------------------------------------------------------------
git diff --check                  Detect whitespaces and conflict markers
git diff --stat                   Diff with statistics on what files have changed and how
git diff --name-only              Show only names of changed files
git diff --name-status            Show only names and status of changed files
git diff --color-words            Word by word diff instead of line by line
----------------------------------------------------------------------------------------------------
git diff origin/master            Changes compare to upstream
git diff @{upstream}              If you're on a given branch, and you want to compare it with an upstream branch you're tracking
----------------------------------------------------------------------------------------------------
git difftool                      Difftool
----------------------------------------------------------------------------------------------------
     Working
    Directory  <----+--------+------+
        |           |        |      |
        |           |        |      |
        V           |        |      |
    "git add"       |        |      |
        |         diff       |      |
        |           |        |      |
        V           |        |      |
     Index     <----+    diff HEAD  |
        |           |        |      |
        |           |        |      |
        V           |        |      |
  "git commit"      |        |      |
        |     diff --cached  |      |
        |     diff --staged  |      |
        V           |        |      |
      HEAD     <----+--------+      |
        |                           |
        |                        diff HEAD^
        V                           |
previous "git commit"               |
        |                           |
        |                           |
        V                           |
      HEAD^    <--------------------+
####################################################################################################
##                                COMMIT
####################################################################################################
git commit                        Commits the staged snapshot
git commit -a                     Stage ALL TRACKED files and commit
git commit -m "[msg]"             With a message (instead of launching a text editor)
git commit --amend                Change commit. Can    change commit message
git commit --amend --no-edit      Change commit. Cannot change commit message
git commit --no-verify            Bypasses some hooks
####################################################################################################
###                               LOGS
####################################################################################################
git log                           Show commit logs
git log [file]                    Show only commits that include the specified file
    -[n]                          Show only the last n commits
    -p                            Show the patch
    -L                            Show the history line range. E.g. git log -L55,60:file.c
----------------------------------------------------------------------------------------------------
    --no-merged                   No merge commits
----------------------------------------------------------------------------------------------------
    --graph                       Show commit logs with ASCII graph
    --stat                        Show statistics for files modified in each commit
    --relative-date               Show date in a relative format
    --oneline                     Shorthand for --pretty=oneline --abbrev-commit used together
----------------------------------------------------------------------------------------------------
    --since, --after              Only show commits after the specified date. E.g. --since=1.week
    --until, --before             Only show commits before the specified date
    --author                      Only show commits from author
    --committer                   Only show commits from committer
    --grep [str]                  Only show commits with a COMMIT MESSAGE message containing the str
    -S [str]                      Only show commits adding or removing CODE matching the str
----------------------------------------------------------------------------------------------------
git log [branch]                  Show all the commits/history on this branch
git log [remote]/[branch]         Show all the commits/history on this REMOTE branch
----------------------------------------------------------------------------------------------------
git log v2.0..master              Reachable from *master* but not *v2.0*
git log v2.0...master             Reachable from *master* and *v2.0*, but not both
git log master..                  Commits in HEAD, not in master
####################################################################################################
###                               SHOW
####################################################################################################
git show [commit/branch/tag]        Outputs METADATA and CONTENT changes of the specified commit
git show [commit/branch/tag]:file   Extract a file from another branch
####################################################################################################
###                               BLAME
####################################################################################################
git blame [file]                  Who changes what and when in [file]
git blame -L 10,15 [file]         Show previous commits for each lines 10-15 of [file]
git blame -l [file]               Show the entire SHA1
git blame -w [file]               Ignores whitespace
git blame -M [file]               Ignores moving text
git blame -C [file]               Ignores moving text into other files
####################################################################################################
###                               BRANCHES
####################################################################################################
git branch                                Lists LOCAL branches (* is the one you checked out(HEAD))
git branch -a                             Full list
git branch -v                             Show last commit msg
git branch -vv                            Show last commit msg and remotes (VERY GOOD)
git branch [branch]                       Create new branch(based on current HEAD). NO checkout!!
git branch -d [branch]                    Delete branch. SAFE(only if branch is merged)
git branch -D [branch]                    Delete branch. DANGEROUS(even if it has unmerged changes)
git branch --merged                       List branches already merged into current branch
git branch --no-merged                    List branches not yet merged into current branch
git branch --edit-description [branch]    Edit branch description(used by other commands)
git branch --contains / no-contains [SHA] List only the branches that contain the named commit
git branch -m newName                     Rename the current branch
git branch -m oldName newName             Rename a branch
git branch -r                             List remote branches
git branch [branch] [SHA]                 Create the branch via HASH
git branch [branch] HEAD~3                Create the branch via SYMBOLIC REF
----------------------------------------------------------------------------------------------------
git branch --set-upstream-to origin feature-branch
----------------------------------------------------------------------------------------------------
git branch --set-upstream <remote-branch>
     -sets the default remote branch for the current local branch
     -Any future git pull command (with the current local branch checked-out), will attempt to bring in commits from the <remote-branch> into the current local branch
     -One way to avoid having to explicitly do --set-upstream is to use the shorthand flag -u along-with the very first : git push -u origin local-branch

----------------------------------------------------------------------------------------------------
git branch --track [localbranch] [branch-To-track]
git branch --track feature1 origin/master         ## Branch feature1 set up to track remote branch refs/remotes/origin/master.
                                                  ## When branches are created using the --track option, they will be set up to linked to the remote branch
----------------------------------------------------------------------------------------------------
-git branch -vv       :  master    d4a1331 [origin/master] add something in testje    ==> Local branch "master" is tracking the remote-tracking branch "origin/master"
                         feature   ed2c752  some commit text                          ==> local branch "feature" are not tracking anything (non-tracking-local-branch)

####################################################################################################
###                                CHECKOUT
####################################################################################################
git checkout [file/commit/branch/tag]    Checking out and update workdir (NEED CLEAN WORKDIR)
git checkout -b [branch]                 Create branch [branch] and switch to it
git checkout -b [branch] [tag/commit]    Create branch from a tag or commit
----------------------------------------------------------------------------------------------------
git checkout something                   Checkout the BRANCH something
git checkout -- something                Checkout the FILE something
----------------------------------------------------------------------------------------------------
git checkout -- [file]                   Discard unstaged changes to [file]
git checkout -- .                        Discard unstaged changes, for all unstaged files
git checkout -                           Checkout your last branch
----------------------------------------------------------------------------------------------------
git checkout [branch] -- path/to/file    Checkout file from another branch without switching branches
git checkout [commit] -- [file]          Checkout file from another branch
----------------------------------------------------------------------------------------------------
-Any commits you make in detached HEAD mode will get lost. Git won’t prevent you from making commits
 in detached HEAD mode, but your commits won’t be added to a branch. Therefore you pretty much lose
 track of them next time you run a checkout command. If you accidentally lose commits this way, you
 will have to resort to advanced Git sorcery for a chance to recover them.
-Files that were never added to Git are unaffected by this command. Git doesn’t keep their history,
 so git checkout will not touch them.
----------------------------------------------------------------------------------------------------
-You may switch branches with uncommitted changes in the work-tree if and only if said switching does
 not require clobbering those changes !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 A git checkout branch2 would have to do this:
    -For every file that is in branch1 and not in branch2,1 remove that file.
    -For every file that is in branch2 and not in branch1, create that file (with appropriate contents).
    -For every file that is in both branches, if the version in branch2 is different, update the working tree version.
-Creating a new branch (git checkout -b newbranch) is always considered "safe": no files will be added,
 removed, or altered in the work-tree as part of this process, and the index/staging-area is also untouched.
----------------------------------------------------------------------------------------------------
-git checkout --track origin/mybranch     ## shorthand for git checkout -b [branch] [remotename]/[branch]
                                          ## where [remotename] is origin in this case and [branch] is twice the same, mybranch

####################################################################################################
###                                REVERT
####################################################################################################
git revert [commit]           Create new commit that undoes [commit]
####################################################################################################
###                                RESET
####################################################################################################
git reset --soft              Move HEAD
git reset --mixed/nothing     Update index (remove from stage) as well
git reset --hard              Update workdir as well
----------------------------------------------------------------------------------------------------
git reset HEAD                Reset the last commit
git reset HEAD~1              Reset the most recent commit. Will undo the last commit
git reset HEAD~number         Remove the latest x commits, keep master clean
----------------------------------------------------------------------------------------------------
-git reset is equivalent to git reset HEAD
-get your git reset --hard HEAD~1 back with using git reflog and then checkout again!!!
####################################################################################################
###                                STASHES
####################################################################################################
git stash OR git stash save                 Temporarily STORES all modified TRACKED file(s)
git stash -u                                Stash including UNTRACKED file(s)
git stash -a OR stash save --all            Stash ALL, including UNTRACKED and IGNORED file(s)
git stash list                              List stashes (stash name, related branch and message)
git stash clear                             Delete ALL stashes
git stash save "msg"                        Stash with own msg
git stash show [stash]                      Show stash
git stash pop [stash]                       Apply a stash. Removes stash from the stash list
git stash drop [stash]                      Drop a stash
git stash apply [stash]                     Reapply stash. Does NOT remove the stash from the list
git stash apply --index                     Reapply stashed changes along with staged changes.
                                            Preserve the state of files (staged vs working)
git stash branch [branch] [stash]           Create branch [branch] from stash
git stash show -p | git apply --reverse     Undo a git stash apply
----------------------------------------------------------------------------------------------------
-Note that git stash save actually means "Commit all the changes, but on no branch at all,
 then remove them from where I am now."
----------------------------------------------------------------------------------------------------
==> [stash] is optional. Default stash@{0}
==> Git stash is "carry over" from branch to branch --> meaning the stash can be applied to all
    branches. E.g if you work in a wrong branch, stash, checkout other branch, stash pop and done!!!
==> It is not possible to push a stash to a remote repository, so it is only for your own use
==> By default, stash are marked as WIP [branch] [commit-hash]
==> If you want to stash only specific files, do the following:
        1. git add <file you don't want to stash>
        2. git stash save --keep-index
        3. git reset
==> git stash pop throws away the (topmost, by default) stash after applying it, whereas git stash
    apply leaves it in the stash list for possible later reuse

# Applying the changes of a single file from a stash
git diff stash@\{0\}^1 stash@\{0\} -- path/to/your/file | git apply
------------------------------------------------------------------------------------------------------
$ git stash list
stash@{0}: On master: pre-commit-1534666282
stash@{1}: WIP on master: 8b74946 new commit

======> SAME!!!!!!!!!!!!!!!!!!!!!!!!!

$ cat .git/logs/refs/stash
0000000000000000000000000000000000000000 6850d1d3bd072d20860217f6d38aa56d1bbb9592 locktree <mitchell@hotmail.com> 1530038236 +0200      WIP on master: 8b74946 new commit
6850d1d3bd072d20860217f6d38aa56d1bbb9592 872a9d99b6aa8e777c17f5ecc1256d11a38dcf0d locktree <mitchell@hotmail.com> 1534666282 +0200      On master: pre-commit-1534666282

####################################################################################################
###                                PUSH
####################################################################################################
git push [remote] [branch]                          Pushing local changes to a remote
git push [remote] [tag]                             Push a single tag
git push [remote] --tags                            Push all tags
git push [remote] --all                             Push all local branches
git push [remote] [localbranch]:[remotebranch]      Renaming branches
git push [remote] :[remotebranch]                   Delete a remote branch or tag
git push -u [remote] [branch]                       To setup your upstream
----------------------------------------------------------------------------------------------------
git push -u <remote> <branch>   ## SETTING UPSTREAM
 E.g. : git push -u origin feat/new-feature-toggle
        ==> Once you setup your upstream you only need to do
        git push
----------------------------------------------------------------------------------------------------
-Doing a push with specify branch: will push to the remote with the same branch name
-Pushing to a remote by default pushes to a branch with the same name
-If the branch does not exists on the remote side it will be automatically created
-git push -u origin master  ===> pushes the "master" branch to "origin" remote and sets up tracking
----------------------------------------------------------------------------------------------------
Default behavior for git push
  nothing  - do not push anything.
  matching - push all branches having the same name in both ends.
  upstream - push the current branch to its upstream branch.
  simple   - like upstream, but refuses to push if the upstream branch's name is different from the local one.
  current  - push the current branch to a branch of the same name.
----------------------------------------------------------------------------------------------------
-In the push command, you can use remotes or you can simply use a URL directly. An example that uses the URL:
    git push git@github.com:git/git.git master
---------------------------------------------------------------------------------------------------
deleting remote branches in git
   $ git push origin --delete feature/login
   $ git push <remote_name> --delete <branch_name>
---------------------------------------------------------------------------------------------------
-git push -u origin myNewBranch   # Pushes your newly created local branch "myNewBranch" to the remote "origin".
                                  # So now a new branch named "myNewBranch" is created on the remote machine named "origin"
####################################################################################################
###                         REMOTE
####################################################################################################
git remote                          Create/view/delete remote connections to other repos
git remote -v                       List all remotes(include URL)
git remote add [name] [url]         Add connection to a remote repo. [name] is shortcut for url in other cmds
git remote rename [old] [new]       Rename a remote connection
git remote rm [name]                Remove connection to the remote repo
git remote show [remote]            Show information about a remote
git remote set-url [name] [url]     Set URL
git remote get-url [name]           Get URL

git remote prune                    Removes your local remote tracking braches where the branch no longer exists on the remote
git remote prune origin --dry-run   Lists branches that can be deleted/pruned on your local.
git remote prune origin
git remote --prune                  Deletes stale references associated with <name>.
                                    By default, stale remote-tracking branches under <name> are
                                    deleted, but depending on global configuration and the
                                    configuration of the remote we might even prune local
                                    tags that haven’t been pushed there. Equivalent to
                                    git fetch --prune <name>, except that no new references will be fetched.

------------------------------------------------------------------------------------------
-By default, your clone refers to that remote as origin
------------------------------------------------------------------------------------------
SSH
    -Bi-directional data transfer
    -Encrypted
    -Typically authenticated, especially without passwords
Git
    -Pull only
    -Intelligent transfer mechanism
HTTP/S
    -Bi-directional data transfer
    -Authenticated
    -Unintelligent transfer mechanism
------------------------------------------------------------------------------------------
-Here's a sample project with multiple remotes, GitHub & GitLab:
    ## Add remote repo for GitHub"
    $ git remote add github https://github.com/Company_Name/repository_name.git
    ## Add remote repo for GitLab
    $ git remote add gitlab https://gitlab.com/Company_Name/repository_name.git
    ## Now you have multiple remotes in the project. Double check with git remote -v
    $ git remote -v
    github https://github.com/Company_Name/repository_name.git (fetch)
    github https://github.com/Company_Name/repository_name.git (push)
    gitlab https://gitlab.com/Company_Name/repository_name.git (fetch)
    gitlab https://gitlab.com/Company_Name/repository_name.git (push)
    ## How do you push to multiple repositories?
    $ git push github && git push gitlab
------------------------------------------------------------------------------------------
12:50:21 [~/TESTING/testing] @ [$] @ (master|16h46m) > cd .git/refs/remotes/origin/
total 16
-rw-r--r-- 1 mitchell mitchell 32 Nov 16  2017 HEAD
-rw-r--r-- 1 mitchell mitchell 41 Feb  4 15:17 bla
-rw-r--r-- 1 mitchell mitchell 41 Feb  4 15:18 onzin
-rw-r--r-- 1 mitchell mitchell 41 Mar 24 14:08 master

12:51:25 [~/TESTING/testing] @ [$] @ (master|16h47m) > git remote show origin
* remote origin
  Fetch URL: https://github.com/mitchell/testing
  Push  URL: git@github.com:mitchell/testing
  HEAD branch: master
  Remote branches:
    bla    tracked
    master tracked
    onzin  tracked
------------------------------------------------------------------------------------------
git remote add origin-gitlab https://gitlab.com/${GIT_USER_NAME}/${GIT_REPO_NAME}.git
git remote add origin-bitbucket https://bitbucket.org/${GIT_USER_NAME}/${GIT_REPO_NAME}.git
------------------------------------------------------------------------------------------
$ git remote -v
origin	git://git.kernel.org/pub/scm/git/git.git (fetch)
origin	git://git.kernel.org/pub/scm/git/git.git (push)
####################################################################################################
###                          FETCH
####################################################################################################
git fetch [name]       -Pull data from remote [name] WITHOUT merging(so workdir will NOT be modified)
                       -Since fetched content is represented as a remote branch, it has absolutely
                        no effect on your local development work
                       -Remote branches are just like local branches, except they represent commits
                        from somebody else’s repo
                       -git fetch origin by default fetches everything from the remote named "origin"
                        and updates (or creates) the so-called "remote-tracking branches" for that remote.
                       -Say, for the remote named "origin" which contain branches named "master" and
                        "feature", running git fetch remote will result in the remote-tracking
                        branches named "origin/master" and "origin/feature" being updated (or created,
                        if they're not exist).  You could see them in the output of git branch -a
------------------------------------------------------------------------------------------
git fetch [remote] [branch]   Fetches a specific [branch], from the repo
------------------------------------------------------------------------------------------
-You can do a git fetch at any time to update your remote-tracking branches under refs/remotes/<remote>/
------------------------------------------------------------------------------------------
----- SHOW THE DIFF-----
$ git fetch
$ git log master..origin/master    ## show commit logs of changes
$ git diff master...origin/master  ## show diffs of changes
------------------------------------------------------------------------------------------
git fetch origin --prune           ## If a branch has been deleted in the origin remote, and you had a
                                      local branch which was tracking it, the local branch gets deleted as well
git fetch origin --prune           ## Git to remove any references to branches that no longer exist on the
                                      remote. This ensures that you don't look at stale data
------------------------------------------------------------------------------------------
git fetch --prune                  ## Before fetching, remove any remote-tracking references that no longer
                                      exist on the remote. Tags are not subject to pruning if they are
                                      fetched only because of the default tag auto-following or due
                                      to a --tags option.
------------------------------------------------------------------------------------------
git fetch origin by default fetches everything from the remote named "origin" and updates (or creates)
the so-called "remote-tracking branches" for that remote. Say, for the remote named "origin" which
contain branches named "master" and "feature", running git fetch remote will result in the remote-tracking
 branches named "origin/master" and "origin/feature" being updated (or created, if they're not exist).
####################################################################################################
###                            TAGS - MANAGING RELEASES
####################################################################################################
git tag                           Show tags
git tag [tagname]                 Mark CURRENT commit as a lightweight tag (as a reference in .git/refs/tags/tagname).
                                  Store only hash of the commit they refer to (avoid using the -a or -m options,otherwise
								  it will be annotated)
git tag [tagname] [commit]        Tagging old commits
git tag -s [tagname]              Create signed tag. To guarantee the authenticity of the tag. This uses gpg to sign
git tag -a [tagname]              Create annotated tag
git tag -m "msg"                  Create tag with message
git tag -f                        Replacing old tag, by forcing
----------------------------------------------------------------------------------------------------
git push origin [tagname]         Push a single tag
git push origin --tags            Push all tags
----------------------------------------------------------------------------------------------------
git tag -d [tagname]              Delete tag(locally)
git push origin :[tagname]        Delete tag from remote repo if it was already pushed
git push --delete origin [tag]    Delete tag from remote repo if it was already pushed(same as above)
----------------------------------------------------------------------------------------------------
git fetch tag                     Fetch a single tag
git fetch --tags                  Fetch all tags
----------------------------------------------------------------------------------------------------
git show [tagname]                           Show tag details (git object)
git cat-file -p "$(cat .git/refs/tags/v1)"   Show the tag object of tag v1
git cat-file -t [tag]                        Determine if a tag is annotated: --->Outputs "commit" for lightweight, "tag"
                                             for annotated
----------------------------------------------------------------------------------------------------
git describe                   Gives an identifier of the repository, based off of the nearest ANNOTATED tag
----------------------------------------------------------------------------------------------------
-A tag is a named reference to a specific commit in your repository
-Branches are mutable references, tags are immutable references
-Tags are not commit by default
-Git push doesn't transfer tags to remote servers
-Annotated tags contain information about the author, a message, etc.(contains an additional tag
 object in the Git repo)
-Lightweight(non-annotated) tags act like simple pointers to a specific commit
-Adds a tag reference in refs/tags/
-If the tag is a lightweight tag, the message of the last commit is shown
-remote tags: git ls-remote --tags origin
----------------------------------------------------------------------------------------------------
-LIGHTWEIGHTED tags
    -attached to an existing commit
    -just a pointer
    -does not allow you to store any information that specific to the tag
    -They are created with the absence of the -a, -s, or -m options and do not contain any extra info
    -Whereas a "lightweight" tag is simply a name for an object (usually a commit object)
----------------------------------------------------------------------------------------------------
-ANNOTATED tag
    -A tag that has its own commit hash and is, as such, stored as a separate object in git
    -You can add a tag message, GPG sign it, and the tagger is stored
    -git tag -s -a -m "JIRA-11: Include your tag message here" 0.12.0
        -s will GPG sign your tag. More about this further down.
        -a will create an annotated tag.
        -m "<message>" will add a tag message.
        If you need to amend / fix / replace an existing tag, you can use the -f parameter to overwrite the current tag.
    -Annotated tags give you separation between tagger (reviewer and/or releaser) and author/committer.
    -You can also put this in there:
        -Which changes are included in this change set?
        -To which JIRA tickets are these changes related?
        -Why have we decided to release these changes as a new tag?
        -Are any additional actions required to make this release work? (Play-books)
    -By default, Git only looks at annotated tags as a baseline for commands like git describe
    -Annotated tags are meant for release while lightweight tags are meant for private or temporary object labels.
    -Always use annotated tags
####################################################################################################
###                      CLEAN
####################################################################################################
git clean                    Removes UNTRACKED files from workdir. FOREVER! PERMANENT!
git clean -n                 Dry run
git clean -f                 Remove UNTRACKED FILES from the current directory
git clean -fd                Remove UNTRACKED DIRECTORIES from the current directory
git clean -fx                Remove IGNORED FILES
####################################################################################################
###                       ARCHIVE
####################################################################################################
git archive                  Create an archive
     --format=<fmt>          Format of the resulting archive: tar or zip. The default is tar
     --list                  Show all available formats
     --output=<file>         Write the archive to <file> instead of stdout
     --prefix=<prefix>/      Prepend <prefix>/ to each filename in the archive

EXAMPLE
  -git archive [branchname] --format=[compression] --output=[filename]
  -git archive master --format zip --output /tmp/my-repo.zip
  -git archive master --format zip --output /tmp/my-repo.zip --prefix=my-repo/
####################################################################################################
###                        CHERRY PICK
####################################################################################################
-Take a commit from somewhere else, and "play it back" wherever you are right now
-It will introduce a NEW, distinct commit. Strictly speaking, using git cherry-pick doesn't alter
 the existing history within a repository; instead, it adds to the history.
-Cherry picking is commonly discouraged in developer community. The main reason is because it creates
 a duplicate commit with the same changes and you lose the ability to track the history of the original
 commit. If you can merge, then you should use that instead of cherry picking.
-This is in contrast with other ways such as merge and rebase which normally apply many commits onto
 another branch
-Workflow
    1. Make sure you are on the branch you want to apply the commit to
           git checkout master
    2. Execute the following:
           git cherry-pick <commit-hash>

-If you cherry-pick from a public branch, you should consider using
        git cherry-pick -x <commit-hash>
 ==> This will generate a standardized commit message (cherry picked from commit ea61283)

-Cherry picking a range of commits
        1. git checkout -b newbranch 62ecb3
        2. git rebase --onto master 76cada^

-multiple cherries: git cherry-pick d467740 de906d4
- git cherry-pick --continue        # If the cherry picking gets halted because of conflicts, resolve them and
  git cherry-pick --abort           # If you want to bail of this step out altogether
############################################################################################################################
###                         PATCH AND APPLY
############################################################################################################################
-APPLY PATCH : am + apply
-CREATE PATCH: diff + format-patch
----------------------------------------------------------------------------------------------------------------------------
-patch: A commit exported to text format
-Patching is a way to share out one branch commit to another developer or another branch
-Git would create a separate patch file for each commit
-A better way to exchange whole commits by file is the combination of the commands git format-patch on the sender and then
 git am on the receiver, because it also transfers the authorship info and the commit message.
----------------------------------------------------------------------------------------------------------------------------
git apply [patch]                      Apply a patch to files and/or to the index
git apply --cached / --index [patch]   Apply a patch without touching the working tree
git apply --stat [patch]               Instead of applying the patch, output diffstat for the input. Turns off "apply".
                                       This will show commits which is present in patch file
git apply --check [patch]              Patch also provide a way to test code before applying. Git allows you to test the
                                       patch before you actually apply it
git apply --reverse / -R               Apply the patch in reverse
----------------------------------------------------------------------------------------------------------------------------
git am                                 Apply a series of patches from a mailbox
                                       Takes a mailbox of commits formatted as an email messages (e.g. the output of git
  									     format-patch) and applies them to the current branch.
                                       Uses git apply behind the scenes, but does more work before (reading a Maildir or
									   mbox, and parsing email messages) and after (creating commits).

git am -3        < my.patch            The -3 will do a three-way merge if there are conflicts
----------------------------------------------------------------------------------------------------------------------------
git format-patch                                                  Prepare patches for e-mail submission. also include some
                                                                  meta-information about the commit (committer, date, commit
 																  message, ...) and will contains diff of binary data.
																  Everything will be formatted as a mail, so that it can be
																  easily sent. useful to transmit a commit
git format-patch COMMIT_ID                                        Make a patch for a commit
git format-patch HEAD~2                                           Make patches for the last two commits
git format-patch COMMIT_REFERENCE                                 To convert all commits since the referenced commit (not
                                                                  including it) into patch files.
git format-patch   master --stdout > fix_empty_poster.patch       This will create a new file fix_empty_poster.patch with
                                                                  all changes from the current (fix_empty_poster) against
   																  master
git format-patch -10 HEAD --stdout > last-10-commits.patch        The last 10 patches from head in a single patch file
git format-patch -n <sha> --stdout > specific_commit.patch        To generate path from a specific commit (not the last
                                                                  commit)
----------------------------------------------------------------------------------------------------------------------------
git diff                                A patch created with git diff will be a simple diff with context (think diff -u).
                                        It can also be applied with git apply but the meta-data will not be recreated (as
										they are not present).useful to get a diff between two trees
git diff           > mypatch.patch      Create a patch without commit first, for unstaged changes
git diff --cached  > mypatch.patch      Create a patch without commit first, for staged changes
git diff [id] [id] > mypatch.patch      Create a patch, e.g. with commitid as ids(SHA hashes)
----------------------------------------------------------------------------------------------------------------------------

-A patch created with git format-patch will also include some meta-information about the commit (committer, date, commit
 message, ...) and will contains diff of binary data
-A patch crated with git diff will be a simple diff with context (think diff -u).

############################################################################################################################
###                       SUBMODULE
############################################################################################################################
-git submodule add [path]    Add a new submodule, where path is absolute or relative
                             Creates .gitmodules, which stores the mapping between the project’s URL and the local subdirs
                             E.g.   [submodule "DbConnector"]
                                        path = DbConnector
                                        url = https://github.com/chaconinc/DbConnector

-CLONING A PROJECT WITH SUBMODULES
        git submodule init         Initialize your local configuration file, and
        git submodule update       Fetch all the data from that project and check out

-git checkout -b add-crypto
 git submodule add https://github.com/chaconinc/CryptoLibrary
 git commit -am 'adding crypto library'
 git checkout master
 git status

-git submodule add git@mygithost:billboard lib/billboard
    ----> git submodule add – This simply tells Git that we are adding a submodule. This syntax will always remain the same.
    ----> git@mygithost:billboard – This is the external repository that is to be added as a submodule. The exact syntax will vary depending on the setup of the Git repository you are connecting to. You need to ensure that you have the ability to clone the given repository.
    ----> lib/billboard – This is the path where the submodule repository will be added to the main repository.

-cat .gitmodules in the project dir

-git submodule init
-git submodule update
-git submodule rm lib/billboard
   ---> Remove the submodule’s entry in the .gitmodules file
   ---> Remove the submodule’s entry in the .git/config
   ---> Remove the path created for the submodule.
-git rm --cached lib/billboard
-git submodule update

###### SUBMODULE ################
-This is basically a repository embedded in your main repository
-A couple of advantages of using submodules:
     -You can separate the code into different repositories.
     -You can add the submodule to multiple repositories.

-When you add a submodule in Git, you don't add the code of the submodule to the main repository, you only add information about the submodule that is added to the main repository. This information describes which commit the submodule is pointing at. This way, the submodule's code won't automatically be updated if the submodule's repository is updated.

-ADDING A SUBMODULE:             git submodule add git@github.com:url_to/awesome_submodule.git path_to_awesome_submodule
-GETTING SUBMODULE CODE:         git submodule init
-KEEPING SUBMODULE UP-TO-DATE:   git submodule update

-git config --global alias.update '!git pull && git submodule update --init --recursive'
-.git/modules/the_submodule

---------------------------------------------------------------------------------------------------------
SUBMODULES
- Submodules allow you to keep a Git repository as a subdirectory of another Git repository

-git submodule add [url]     Add a new submodule and will create a .gitmodules file(which stores the mapping between the projects URL and the local subdirectory youve pulled it into)

-EXAMPLE .gitmodules
[submodule "DbConnector"]
	path = DbConnector
	url = https://github.com/chaconinc/DbConnector

-Git sees it as a submodule and doesnt track its contents when youre not in that directory
-When you clone such a project, by default you get the directories that contain submodules, but none of the files within them yet!!! so the directories are empty
-git submodule init to initialize your local configuration file, and git submodule update to fetch all the data from that project and check out the appropriate commit listed in your superproject
-git diff --submodule

-git submodule update --remote, Git will go into your submodules and fetch and update for you
- git config push.recurseSubmodules check

-USEFULL ALIASES FROM GIT-SCM
$ git config alias.sdiff '!'"git diff && git submodule foreach 'git diff'"
$ git config alias.spush 'push --recurse-submodules=on-demand'
$ git config alias.supdate 'submodule update --remote --merge'

-git submodule add git@github.com:url_to/awesome_submodule.git path_to_awesome_submodule
#####################################################################################################
###                GIT MERGE
#####################################################################################################
git mergetool .                 Use graphical merge tool
git merge [branch]              Combines the branch into the current branch (require clean working dir)
git merge --no-ff [branch]      No fast-forward. Always generate a merge commit, useful for documenting all merges
git merge --no-commit           Perform the merge but pretend the merge failed and do not autocommit
----------------------------------------------------------------------------------------------------
-Idea: Give me the changes of the branch and put then into my current branch
-Idea: Merge policy, which gives you traceability at the expense of readability and clarity (going so far as forbidding fast-forward merges)?
-Affects the end of the branch
-Merge commits have multiple parent commits
-After merge conflict, fix it, and do an git add, and then git commit
-------------------------------------------------------------------------------------------------------------------------------------
-PROS: Simple, familiar, preserves history, easy to revert
       Non-destructive operation. Only the target branch is changed. The source branch history remains
       The commits on the source branch are separated from other branch commits. This can be useful if you want to take the feature and merge it into another branch later.
-CONS: No flatten history/Nonlinear history
       Hard for someone to understand and follow what's going on at a particular stage when there are multiple merges
       Polluted history because of a lot of merge commits
       Cannot be 'squashed'
       Debugging using git bisect can become harder
-------------------------------------------------------------------------------------------------------------------------------------
The source       The changeset you're merging from
The destination  The changeset you're merging to
The ancestor     The changeset (or commit) which is the nearest parent of the source and the destination
-------------------------------------------------------------------------------------------------------------------------------------
-MERGE:  $ git checkout feature
         $ git merge master
   (or)
         $ git merge master feature

         $ git checkout master
         $ git merge cool-feature
-------------------------------------------------------------------------------------------------------------------------------------
-UNDOING MERGES
    -FIX THE REFERENCE: if the unwanted merge commit only exits on your local repo: git reset --hard HEAD~
    -REVERSE THE COMMIT: revert. E.g git revert -m 1 HEAD (where this -m 1 flag indicates which parent is the mainline and should be kept
-------------------------------------------------------------------------------------------------------------------------------------
-Fast-forward:    The whole series of the commits will be linear, making it easier to use other tools
                  The default behavior of Git is to use fast-forwarding whenever possible
                  NO commit
                  Is not possible if the branches have diverged
                  If master has NOT DIVERGED, instead of creating a new commit, git will just point master to the latest commit of the feature branch
                  HARD to REVERT, because it is impossible to see from the Git history which of the commit objects together have implemented a feature—you would have to manually read all the log messages. Reverting a whole feature (i.e. a group of commits), is a true headache in the latter situation, whereas it is easily done if the –no-ff flag was used.
-------------------------------------------------------------------------------------------------------------------------------------
-No fast-forward: The --no-ff option
                  There is an ADDITIONAL commit
                  Non fast-forward merge keeps THE NOTATION of explicit branches
                  Use --no-ff because without merge commit you cannot see which branch is used and you cannot easily revert the change
                  If the master is diverged. Merge commits are only required when both branches have new commits
                  EASY to REVERT because of the merge commit
                  3-way-merge(This merge uses an extra (merge)commit to tie together the two branches)
                  Rule of thumb : if the merge "means something" use the --no-ff option
-------------------------------------------------------------------------------------------------------------------------------------
- <<<<<<< - Conflict marker, the conflict starts after this line.
  ======= - Divides your changes from the changes in the other branch.
  >>>>>>> - End of the conflicted lines

-The line (or lines) between the lines beginning <<<<<<< and ======                Locally
-The line (or lines) between the lines beginning ======= and >>>>>>> [HASH]        Introducted by other commit, see hash??
-------------------------------------------------------------------------------------------------------------------------------------
## PREVIEW BEFORE MERGE
git log ..feature        List of changes that will be merged into current branch.
git diff ...feature      Diff from common ancestor (merge base) to the head of what will be merged.
-------------------------------------------------------------------------------------------------------------------------------------
-LOCAL  - The file from the current branch
 BASE   - The common ancestor, how file looked before both changes
 REMOTE - The file you are merging into your branch
 MERGED - The merge result, this is what gets saved in the repo
+--------------------------------+
| LOCAL  |     BASE     | REMOTE |
+--------------------------------+
|             MERGED             |
+--------------------------------+

However, a fast-forward merge is not possible if the branches have diverged. When there is not a linear path to the target branch, Git has no choice but to combine them via a 3-way merge. 3-way merges use a dedicated commit to tie together the two histories. The nomenclature comes from the fact that Git uses three commits to generate the merge commit: the two branch tips and their common ancestor.

-During a git merge, the "ours" branch refers to the branch you're merging into
-git checkout merge-into-ours
-git merge from-theirs

Two types of merges:
   -Fast-forward merge
   -3-way merge
-------------------------------------------------------------------------------------------------------------------------------------
## Common base version of the file.
git show :1:some_file.cpp

## 'Ours' version of the file.
git show :2:some_file.cpp

## 'Theirs' version of the file.
git show :3:some_file.cpp
-------------------------------------------------------------------------------------------------------------------------------------
-i think first stand on a conflict?? right???
if &diff
    map <leader>1 :diffget LOCAL<CR>
    map <leader>2 :diffget BASE<CR>
    map <leader>3 :diffget REMOTE<CR>
endif
 ==> and then git commit
-------------------------------------------------------------------------------------------------------------------------------------
]c - Jump to the next change.
[c - Jump to the previous change.
-------------------------------------------------------------------------------------------------------------------------------------
## PREVIEW BEFORE MERGE
git log ..otherbranch
git diff ...otherbranch
#####################################################################################################
###                GIT REBASE
#####################################################################################################
-IDEA: Rewrites history. If the branch being rebased has been pushed anywhere (shared with anyone other than yourself) then you've screwed up everyone else who has that branch since you've rewritten history.
-IDEA: Affects the start of the branch
-IDEA: Rewrites the changes WITHOUT creating a MERGE commit

-The golden rule of git rebase is to never use it on public/shared branches
-Rebase itself has 2 main modes: "manual" and "interactive" mode
-Internally, Git accomplishes this by creating NEW commits and applying them to the specified base!!!!!!!! NEW COMMITS!!!!
-Rebase will present conflicts one commit at a time whereas merge will present them all at once
-Rebase will produces more conflicts because individual commits in the topic branch can each involve merge conflicts which must be individually resolved (Further lying in history about what happened in each commit).
-While the work is still in progress and a feature branch needs to be brought up to date with the upstream target branch, use rebase  as opposed to pull or merge  not to pollute the history with spurious merges.
 ===> like intermediate update, so that other devs can go further?
-Rebase as team policy is a different thing than rebase as cleanup

------------------------------------------------------------------------------------------------------
-PROS   Streamlines a potentially complex history (Cleans intermediate commits by making them a single commit)
        Flattens the history because it transfers the completed work from one branch to another
        Code history is simplified, linear and readable. Clean history, linear history
        Able to change the commit history by interactive rebase
        Allows 'squashing' of commits (combining multiple commits into a single one)
        Conflicts occur less frequently
        Avoids merge commit “noise” in busy repos with busy branches
        Conflicts occur for an each commit in particular
        Cleans intermediate commits into a single commit
        Clearer history (linear history)(looks like everything happened serial instead of parallel)
-CONS   Difficult to revert
        Provides an incorrect idea of how commits were created
        Pollutes master with a bunch of intermediate commits that may not have been well tested, which makes finding good places in master to checkout difficult
        Rewrites the project history
        Squashing CAN hide the context
        Rebasing doesn't work with pull requests, because you can't see what minor changes someone made
        Usually more complex, and requires more work when dealing with conflicts
------------------------------------------------------------------------------------------------------
-git checkout feature
 git rebase master       (THIS IS THE OTHER WAY AROUND COMPARED WITH GIT MERGE)
------------------------------------------------------------------------------------------------------
 git rebase [base]                         ## Rebase current HEAD onto <base>. <base> can be a commit ID/branch/tag/relative reference to HEAD
 git rebase origin/master                  ## will merge in the requested branch (origin/master in this case) and apply the commits that you have made locally to the top of the history without creating a merge commit (assuming there were no conflicts)
 git rebase -i                             ## interactive rebasing
 git rebase -i HEAD^^                      ## Rollback one commit
 git rebase -i HEAD~[number_of_commits]    ## Squash multiple commits
 git rebase develop                        ## Rebase changes made on current branch over develop
 git rebase master develop                 ## Rebase master onto develop without checking it out
 git rebase --onto master 1a 1b            ## Rebase master onto branch 1b made from branch 1a
 git rebase --continue                     ## If you run into conflicts while rebasing, fix them, and then continue
 git rebase --abort                        ## If the conflicts are too bad and you need to bail out and attempt a normal fast-forward merge
----------------------------------------------------------------------------------------------------------------------------
 git rebase -i HEAD~4      Squeeze them together
                            # Commands:
                            # p, pick = use commit                                            - Apply this commit as is (the default).
                            # r, reword = use commit, but edit the commit message             - Edit commit message.
                            # e, edit = use commit, but stop for amending                     - Edit files and/or commit message.
                            # s, squash = use commit, but meld into previous commit           - Merge/fold into previous commit.
                            # f, fixup = like "squash", but discard this commit's log message - Merge/fold into previous commit discarding its message.
                            # x, exec = run command (the rest of the line) using shell
                            # d, drop = remove commit
----------------------------------------------------------------------------------------------------------------------------
SQUASHING
   -A way to mash several commits into one.
   -To prevent to many small commits, and makes it easier to understand what happened in general
   -Start by running git rebase -i
   -While rebasing, you can also edit the commit description so that it is easier to read

   -git reflog <branch>
     --> you can also see the squashed commits
     --> but reflogs will expire!!!
----------------------------------------------------------------------------------------------------------------------------
-The squash rebase workflow: Before you merge a feature branch back into your main branch (often master or develop), your feature branch should be squashed down to a single buildable commit, and then rebased from the up-to-date main branch.
-If you try to push the rebased master branch back to a remote repository, Git will prevent you from doing so because it conflicts with the remote master branch. But, you can force the push to go through by passing the --force flag, like so
----------------------------------------------------------------------------------------------------------------------------
-Use rebase when:
    -You have a need to merge local changes and don’t need an exact history. Why litter it with merge commits?
    -You prefer a linear history and use git bisect very often (it can get confused with a non-linear history).
------------------------------------------------------------------------------------------------------
undo git rebase --> git reflog
------------------------------------------------------------------------------------------------------
-Rebasing with remote branches requires you to force push. The biggest problem people face is they force push but haven’t set git push default. This results in updates to all branches having the same name, both locally and remotely, and that is dreadful to deal with.
------------------------------------------------------------------------------------------------------
-rebase conflict  :  resolve the merge conflicts and continue rebasing --> git rebase --continue
  --> git rebase --abort to completely undo the rebase
  --> git rebase --skip to completely skip the commit
------------------------------------------------------------------------------------------------------
- if you run git rebase and hit a conflict, the process will stop and exit with a nonzero status. What you could do is check the exit status of the rebase operation, and, if it is nonzero, run git rebase --abort to cancel the rebase
------------------------------------------------------------------------------------------------------
GIT REBASE AUTOSQUASH
1. CHANGE FILE1
   ADD AND COMMIT
2. CHANGE FILE1 AGAIN
   GIT REBASE -I
   ==> You can do an rebase --interactive (or git rebase -i for short), and change the commit line from a pick to a fixup and place the commit beneath the commit to be squashed into
   ==> This cleans up your commits

####################################################################################################
###                                     PULL
####################################################################################################
git pull [remote]             Copies the changes from a REMOTE repo to a LOCAL one
                              Equivalent to: git fetch [remote] && git merge origin/[current-branch]
git pull [remote] [branch]    Fetch changes and directly merge/integrate into HEAD
git pull origin develop       Fetch and merge branch 'develop' from origin
git pull --rebase             ELIMINATES merge commits. Will rewind (undo) all of your local commits,
                              pull down the remote commits then replay your local commits on top of
                              the newly pulled remote commits.
git pull origin master:dev    Updates your local dev branch using the remote origin master branch

----------------------------------------------------------------------------------------------------
PR=pull request
----------------------------------------------------------------------------------------------------
git pull          = git fetch + git merge  against tracking upstream branch
git pull --rebase = git fetch + git rebase against tracking upstream branch
----------------------------------------------------------------------------------------------------
-git pull --rebase   if conflicts, git rebase --continue
                     won't clean up your remote-tracking branches!
                     Avoid merge commits that result from git pull
----------------------------------------------------------------------------------------------------
-If you were trying to do a git pull when you ran into merge conflicts: then: git rebase --continue
----------------------------------------------------------------------------------------------------
git pull --rebase instead of git pull
===> When you want to push your changes to a branch, but someone else already pushed before you, you have to pull in their changes first. Normally, git does a merge commit in that situation
===> git config --global --bool pull.rebase true
----------------------------------------------------------------------------------------------------
instead of git pull use git fetch and merge
-then you know what comes in
----------------------------------------------------------------------------------------------------
########################################################################
## ==> STOP USING GIT PULL!!!!!!!!!!!!!!!!!!!!!!!!! NOW!!!!!!!!!!!!!! ##
########################################################################
OPTION 1 : THE SIMPLE WAY
    $ cd ~/projects/project
    $ git checkout some-branch
    $ git pull origin some-branch
     ==> This works if you haven't made any changes since your last pull, but if you have, git will merge the pulled commits with your local changes
     ==> problems:
            1. unpredictable
            2. Creates a merge commit where there shouldn't be one
            3. nasty bump in your graph
------------------------------------------------------------------------------
OPTION 2 : HOW TO DO:
  1. git fetch origin --prune        ## First, fetch the changes from the remote. This will update remote-tracking branches in the form origin/branch-name, rather than updating your local branch directly.
                                     ## At this point you can checkout the remote-tracking braches (git checkout origin/branch-name), and inspect the changes that you've just pulled down to make sure you actually want them
  2. git checkout branch-name
  3. git merge --ff-only origin/branch-name
  4. if fast-forward error: git rebase --preserve-merges origin/branch-name
     $ git rebase origin/master

  ## ALL IN ONE:
  alias update-from = "!f() { git fetch $1 --prune; git merge --ff-only $1/$2 || git rebase --preserve-merges $1/$2; }; f"
  =====> Add this to ~/.gitconfig, then you can run git update-from <remote> <branch-name> to do all of this in one step

----------------------------------------------------------------------------------------------------

############################################################################################################################
###                         SIGNING
############################################################################################################################
-a private key to sign with
-git config --global user.signingkey 0A46826A
-All you have to do is use -s instead of -a:
    $ git tag -s v1.5 -m 'my signed 1.5 tag'
-To verify a signed tag, you use git tag -v <tag-name>.
-Signing commits: using the -S options ===> $ git commit -a -S -m 'signed commit'
-git log --show-signature -1
-git log --pretty="format:%h %G? %aN  %s"   ==> %G for the sign information!!!!! put this in gitconfig??

############################################################################################################################
###                         OTHER
############################################################################################################################
-get the latest version of the code without caring of local changes:
  -git fetch origin
  -git reset --hard origin/[tag/branch/commit-id usually: master]

-The quotes around the function definition & call are not necessary for *nix environments, only for Windows.
-If the alias expansion is prefixed with an exclamation point, it will be treated as a shell command.
- !f(){...};f

############################################################################################################################
###                         AHEAD VS BEHIND
############################################################################################################################
-if you have 2 commits only locally that you haven't pushed to the remote yet, your local branch is "2 commits ahead" of its remote counterpart branch
-if, on the other hand, there are 4 commits on the remote branch that you haven't downloaded yet, then your local branch is "4 commits behind" its remote counterpart branch.

deteached HEAD, ahead
git ahead vs behind
==> Ahead is the number of commits on this branch that do not exist on the base branch. Behind is the number of commits on the base branch that do not exist on this branch

X - X - A - X - B
      \
        X - C

A is 2 commits behind and 0 commits ahead of B
B is 0 commits behind and 2 commits ahead of A
C is 1 commit behind and 2 commits ahead of A
C is 3 commits behind and 2 commits ahead of B

==> So "behind" means the other branch has commits this one doesn't, and "ahead" means this branch has commits the other does not.

############################################################################################################################
###                         BRANCHES
############################################################################################################################

Local branch
  1. Local non-tracking branch
      -Standalone branches that are not associated with any other branches
      -git branch -d                                            ## Delete
      -git branch [branchname]                                  ## Create
      -git push -u remote [branchname]                          ## To publish a newly created local branch to the remote server
      -git branch --set-upstream-to=remote/branch localbranch   ## Turn local-non-tracking branch into local-tracking branch

  2. Local tracking branch
      -Associated with other branches, and the associated branch can be non-tracking local branches and remote tracking branches
      -local branch that is connected to a remote branch.
      -git branch -d                                       ## Delete
      -git branch --track [branchname] [branch_to_track]   ## Create a new local tracking branch (Example: git branch --track feature origin/feature)
      -git checkout --track -b feature origin/feature      ## If you want to create a local branch based on a remote-tracking branch
      -So origin/master is a remote tracking branch for master in the origin repo.
      -Then you can consider master as a local tracking branch: it tracks the remote tracking branch origin/master which, in turns track the master branch of the upstream repo origin

  3. Remote branch
      -A branch located on a remote machine or server (in most cases origin)
      -The remote branch has the form of (remote)/(branch)
      -push -u origin [myNewBranch]            ## Push a new branch and track it
      -git push --delete remote [branchname]   ## Delete a branch on a remote machine
      -git remote show                         ## View all remote branches (what about git branch -r?)

  4. Remote tracking branches
      -Are references (points) to the state of branches (remote branches) in your remote machines (repos)
      -Remote-tracking branches are READ-ONLY to the local user
      -You can update your remote-track branches using git fetch.
      -Remote Tracking Branches get their contents from the remote repository
      -A remote tracking branch is a local copy of a remote branch
      -They’re used to link what you’re working on locally compared to what’s on the remote
      -Usefull for status/pull/fetch/clone
      -Remote references are references (pointers) in your remote repositories, including branches, tags, and so on
      -The origin/master ref is in .git/refs/remotes/origin/master
      -git branch -rd remote/branch_name     ## Delete a remote-tracking branch

  5. tracking branch
      -To see which branches are tracking branches: git branch -vv
           $ git branch -vv
             branch1    c98bacf  [origin/branch1] A random change of 24459 to ideas2.txt    ===> tracking!!
             experiment 09a0eb9  A random change of 16603 to list2.txt                      ===> NOT tracking!!
           * master     09a0eb9  [origin/master] A random change of 16603 to list2.txt      ===> tracking!!

      -remove a tracking branch:            git branch --unset-upstream
      -link a branch to an upstream branch: git push -u origin feature
      -Tracking branches can be modified by users.
      -Checking out a local branch from a remote branch automatically creates what is called a tracking branch.

  6. Upstream tracking branch
	    -Upstream is the name of remote branch to which our local branch is synced. Every local branch has exactly one upstream set.
	    -Setting upstream has effect on many commands e.g. push, pull, merge. When these commands are used without any conditional arguments, remote branch information is retrieved from its upstream
        -upstream tracking branch: master -> origin/master
		-git remote add upstream git@bitbucket.org:some-gatekeeper-maintainer/some-project.git    ## Will add an upstream
----------------------------------------------------------------------------------------------------------------------------
-Both Tracking Branches and Remote Tracking Branches are created on the git client
-Checking out a local branch from a remote-tracking branch automatically creates what is called a "tracking branch" (and the branch it tracks is called an "upstream branch").
-When you clone a remote repository all the remote branches are tracked and set as upstream branch for the new checked out master
-When you clone a repository the current HEAD (usually ‘master’) is checked out for you, but also, it’s setup to track ‘origin/master’, and thus ‘origin/master’ is the “upstream” of ‘master’.
-local and remote branches actually have nothing to do with each other. They are completely separate objects in Git
-The local branch, local tracking branch, and remote tracking branch belong to the branches on the local machine,
-Remote references are references (pointers) in your remote repositories, including branches, tags, and so on
-   .git/refs/heads/ [for local branches]
    .git/refs/remotes/ [for tracking branches]
--------------------------------------------------------------------------------------------------------
-If you already created the branch, you can update only the tracking info:
    git branch --set-upstream-to master dev
--------------------------------------------------------------------------------------------------------
-When you have a tracking branch set up, you can reference its upstream branch with the @{upstream} or @{u} shorthand.
 So if you're on the master branch and it's tracking origin/master, you can say something like git merge @{u} instead of git merge origin/master if you wish.
--------------------------------------------------------------------------------------------------------
-How do you track a remote branch
   1. When you're starting to work on an EXISTING remote branch
         ==> $ git checkout --track origin/dev
         ==> This creates a new local branch with the same name as the remote one - and directly establishes a tracking connection between the two.
   2. When you're PUBLISHING a local branch
         ==> $ git push -u origin dev
   3. When you decide at a later point in time
         ==> in cases when you simply forgot
         ==> $ git branch -u origin/dev
--------------------------------------------------------------------------------------------------------
-master          Default branch (local)
-origin          Default upstream repo. The default alias to the URL of your remote repository. Your fork
-HEAD            Current branch(pointer to current local branch). Mostly the latest commit in your branch
-remote          Repo stored on another computer
-origin/master   Remote branch (which is a local copy of the branch named "master" on the remote named "origin")
-upstream        Generally refers to the original repo that you have forked
--------------------------------------------------------------------------------------------------------
-You will use upstream to fetch from the original repo (in order to keep your local copy in sync with the project you wanted to contributed to).
-You will use origin to pull and push since you can contribute to your own repo.
-You will contribute back to the upstream repo by making a pull request.

############################################################################################################################
###                         PRUNING
############################################################################################################################

--> Let's start with git prune. This removes objects that are no longer being referenced, it does not remove references
--> git remote prune origin and git fetch --prune both operate on references under refs/remotes/... (I'll refer to these as remote references).
    It doesn't affect local branches.

-->git remote prune and git fetch --prune do the same thing: deleting the refs to the branches that don't exist on the remote, as you said.
   The second command connects to the remote and fetches its current branches before pruning.
   However it doesn't touch the local branches you have checked out, that you can simply delete with
       git branch -d  random_branch_I_want_deleted

--> git prune does something different, it purges unreachable objects, those commits that aren't reachable in any branch or tag, and thus not needed anymore

################################################################################################################################################################################
###  ADVANCED   ADVANCED   ADVANCED   ADVANCED   ADVANCED   ADVANCED   ADVANCED   ADVANCED   ADVANCED   ADVANCED   ADVANCED   ADVANCED   ADVANCED   ADVANCED   ADVANCED   ADVANCED
################################################################################################################################################################################

####################################################################################################
###                                MKTREE
####################################################################################################
git mktree                       Generate new tree objects from git ls-tree formatted output
                                 $ cat /tmp/tree.txt | git mk-tree
                                 f66a66ab6a7bfe86d52a66516ace212efa00fe1f
####################################################################################################
###                                REFLOG
####################################################################################################
git reflog                        Show reference logs. (log of actions against branches/references)
git reflog show                   Show reference reflogs for LOCAL repo
git reflog expire                 Cleans up old/unreachable reflog entries
git reflog delete [id]            Delete reflog entry
----------------------------------------------------------------------------------------------------
-Reflog output:
  column 1 : Commit SHA-1 that is the result of the action
  column 2 : Shortcut reference that can be used anywhere a regular reference can be
  column 3 : Action, e.g., checkout, commit, merge, etc., and a short description of the action
----------------------------------------------------------------------------------------------------
-The reflogs record changes that are not saved as part of the commit history—things like rebases,
 fast-forward merges, resets and the like. There is one reflog per branch. The reflog is not a
 public part of the repository, it is strictly specific to your local copy, and information is only
 kept in it for a limited time (2 weeks by default). It provides a safety net, allowing you to
 recover from mistakes like deleting or overwriting things you didn’t mean to.
####################################################################################################
###                                FSCK
####################################################################################################
git fsck                          File System Check. Verifies connectivity/validity of the objects
git fsck --lost-found             Show lost commit
git fsck --unreachable            Show unreachable
----------------------------------------------------------------------------------------------------
-searches the Git object store, and will report objects that are dangling or unreachable from a
 named reference. This way, we can find commits, or even blobs, that have been lost to us because
 they do not exist in the directed acyclic graph (DAG) of Git, but do exist in the object store itself
----------------------------------------------------------------------------------------------------
-Output: git fsck --unreachable
unreachable  blob    20c1e21948ab5d9553c11fa8a7230d73055c207e
unreachable  commit  16f6063abde9dcd8279fb2a7ddd4998aaf44acc7
unreachable  commit  41a324739bc3f1d265ecc474c58256e3a4ad4982
unreachable  blob    c4131dc6d091b1c16943554fa2396f5d405e8537
----------------------------------------------------------------------------------------------------
-Check the results of fsck: git-show and git-cat-file
####################################################################################################
###                                GC - GARBAGE COLLECTOR
####################################################################################################
git gc                            Cleanup unreachable objects and optimize the local repo
####################################################################################################
###                                COUNT-OBJECTS
####################################################################################################
git count-objects                 Count unpacked number of objects and their disk consumption
git count-objects -v              Verbose
####################################################################################################
###                                DIFF-INDEX
####################################################################################################
git diff-index <tree-ish>         Like diff. Displays mode,hash,filename, NO content!
git diff-index --cached <tree-ish>
----------------------------------------------------------------------------------------------------
-Output:
:100644 100644 b83702ec2eee739a306d8ff6919efe3f4ed3c97a 0000000000000000000000000000000000000000 M      new.txt
####################################################################################################
###                                WRITE-TREE
####################################################################################################
git write-tree                    Create tree object from current index. Write the current index to a tree
####################################################################################################
###                                READ-TREE
####################################################################################################
git read-tree                     Reads tree information into the index
####################################################################################################
###                                GREP
####################################################################################################
git grep [str]                    Print lines matching a pattern (tracked files only)
                                  The git grep version will only search in files tracked by git,
                                  whereas the grep version will search everything in the directory
                                  "git grep" is a lot faster than grep in a large codebase. One
                                  obvious reason is that "git grep" ignores non-checked-in files in
                                  the project directory. That's because git-grep doesn't need to
                                  bother to go through the filesystem for the on-disk files. It greps
                                  directly from the object storage instead.
####################################################################################################
###                                CAT-FILE
####################################################################################################
git cat-file <object> -t          Show object TYPE
git cat-file <object> -s          Show object SIZE
git cat-file <object> -p          Show contents of <object>
git cat-file <object> -e          Exit with zero status if <object> exists and is a valid object
---------------------------------------------------------------------------------------------------------
-git cat-file [commit_id] -p
      tree fb26ca0289762a454db2ef783c322fedfc566d38
      author = <=> 1537700068 +0100
      committer = <=> 1537700068 +0100

      Add helloworld
---------------------------------------------------------------------------------------------------------
-git cat-file [tree_id] -p
      100644 blob a0423896973644771497bdc03eb99d5281615b51 helloworld
####################################################################################################
###                                UPDATE-INDEX
####################################################################################################
git update-index                                Register file contents in the working tree to the index(equivalent: git add)
git update-index --add <path>                   Add a file to the Git index
git update-index --assume-unchanged <file>      Ignore changes in a tracked file
git update-index --no-assume-unchanged <file>   Then when you want to track changes again
####################################################################################################
###                                UPDATE-REF
####################################################################################################
git update-ref refs/heads/<branch> <commit>      Create a Git branch which points at the given commit
####################################################################################################
###                                NAME-REV
####################################################################################################
git name-rev [commit]              Find symbolic names for given revs. Output is relative to the local refs. Output: 3cd7388 master~2
git name-rev --name-only HEAD      Instead of printing both the SHA-1 and the name, print only the name

-git name-rev --name-only 50f3754    ##Find out if a change is part of a release
"tags/v2.3.8~6"
####################################################################################################
###                                REV-LIST
####################################################################################################
git rev-list [commit]              Lists commit objects in reverse chronological order
git rev-list --objects --all       Lists commit object ids
git rev-list --count [commit]      To get a commit count for a commit
git rev-list --all --count         To get the commit count across all branches

## How to tell which commit a tag points to in Git?
$ git rev-list -n 1 $TAG

what commits are reachable from another branch, but not from the local branch: ahead
    git rev-list "$localref..$anotherref"
what commits are reachable from the local branch, but not from the other branch: behind
    git rev-list "$anotherref..$localref"
####################################################################################################
###                                REV-PARSE
####################################################################################################
git rev-parse [commit]   Pick out and massage parameters. Used by many other commands to do many different things.
  --short                For printing a shorter unique SHA1
  --verify               To verify that the specified object is a valid git object
  --git-dir              For displaying the abs/relative path of the the .git directory
  --is-bare-repository   Checking if the repo is a bare using
  --parse-opt            To normalize arguments in a script (kind of similar to getopt) and print an output string that can be used with eval
  --abbrev-ref HEAD      BRANCH: --> returns master
  --show-toplevel        ROOT/toplevel
  --is-inside-git-dir    check if the current directory is in .git before running git checks
  --is-inside-work-tree  Check if the current directory is in a Git repository
  --branches
  --tags
  --remote
  --verify refs/stash    Check for stashed files
####################################################################################################
###                                SHOW-REF
####################################################################################################
git show-ref         List references in a local repository with the associated commit IDs
   --head            Show the HEAD reference
   --tags,--heads    Limit to "refs/heads" and "refs/tags", respectively. These options are not mutually exclusive
   --dereference     Dereference tags into object IDs as well. They will be shown with "^{}" appended
   --hash[=<n>]      Only show the SHA-1 hash, not the reference name
   <pattern>         Show references matching one or more patterns
----------------------------------------------------------------------------------------------------
-The ^{} is the syntax used to dereference a tag
  $ git show-ref --tags --dereference
  bb944682f7f65272137de74ed18605e49257356c    refs/tags/v0.1.6
  771a930dc0ba86769d6862bc4dc100acc50170fa    refs/tags/v0.1.6^{}
  a72251d945353a360087eb78ee75287c38a1c0e6    refs/tags/v0.1.7
  d69e66d7c915b9682618b7f304b80cc0ae4c7809    refs/tags/v0.1.7^{}
####################################################################################################
###                                HASH-OBJECT
####################################################################################################
git hash-object                   Compute object ID and optionally creates a blob from a file
git hash-object [file]            Prints unique sha1 for the file
                                  Add a file to the Git object store
                                  Creating a blob in your Git repository and getting a SHA back
                                  To create a blob object from an existing file, just run it with the '-w' option
                                  Will take something and compute its object ID
####################################################################################################
###                                LS-FILES
####################################################################################################
git ls-files                        Show information about files in the index(default) and the working tree
    -c, --cached                    Show cached files (default)
    -d, --deleted                   Show deleted files
    -m, --modified                  Show modified files
    -o, --others                    Show other files. Seems to be equal to untracked + ignored
    -i, --ignored                   Show ignored files
    -s, --stage                     Show staged contents' object name. what's in the index, Lists files added to git index
    -k, --killed                    Show files on the filesystem that need to be removed
    -u, --unmerged                  Show unmerged files
    -x, --exclude <pattern>         Skip files matching pattern
    -X, --exclude-from <file>       Exclude patterns are read from <file>
    --exclude-per-directory <file>  Read additional per-directory exclude patterns in <file>
    --exclude-standard              Add the standard git exclusions
    --exclude-standard -o           Untracked files only
    --exclude-standard -o -i        Ignored files only
####################################################################################################
###                                LS-REMOTE
####################################################################################################
git ls-remote [url]                        List references in a remote repository.
git ls-remote --heads origin               It lists the remote head references in your repo
git ls-remote --tags                       Limit to only refs/heads and refs/tags, respectively
git ls-remote --tags origin
git ls-remote --tags /url/to/upstream/repo
----------------------------------------------------------------------------------------------------
git ls-remote and git ls-remote origin ARE EQUAL IF YOUR REMOTE IS CALLED origin... which is the case by default!!
----------------------------------------------------------------------------------------------------
E.g: git ls-remote git://git.kernel.org/pub/scm/git/git.git
####################################################################################################
###                                LS-TREE
####################################################################################################
git ls-tree [branch]              List the contents of a tree object. Files and directories, top level only
git ls-tree -l                    Also show the size of the object
git ls-tree -d                    Only directories
git ls-tree -r                    Recurse, only files
git ls-tree -r -d                 Recurse, only directories
git ls-tree -r -t                 Recurse, both directories and files
git ls-tree --name-only           List only filenames
git ls-tree --name-only [branch]
git ls-tree --name-status         List only filenames
----------------------------------------------------------------------------------------------------
-git ls-tree -r --name-only develop helpers/     List files in a folder from another branch
 git show develop:helpers.php                    Read a file from another branch
----------------------------------------------------------------------------------------------------
-The contents of your files are stored in blobs
-OUTPUT FORMAT: <mode> SP <type> SP <object> TAB <file>
-git ls-tree only works with git refs, e.g. git ls-tree HEAD
----------------------------------------------------------------------------------------------------
-First two digits show file type, the third one is about set-uid/set-gid/sticky bits, last 3 oct digits are file mode
-Valid modes (as binary and octal):
    0100000000000000 (040000): Directory
    1000000110100100 (100644): Regular non-executable file(permissions 0644)
    1000000110110100 (100664): Regular non-executable group-writeable file
    1000000111101101 (100755): Regular executable file
    1010000000000000 (120000): Symbolic link
    1110000000000000 (160000): Gitlink, object from another repository, fast-import
####################################################################################################
###                                DESCRIBE
####################################################################################################
git describe [commit]     Show the most recent annotated tag that is reachable from a commit
  --all                   Instead of using only the annotated tags, use any ref found in refs/namespace.
                          This option enables matching any known branch, remote-tracking branch, or lightweight tag
  --tags                  Instead of using only the annotated tags, use any tag found in refs/tags namespace.
                          This option enables matching a lightweight (non-annotated) tag
  --contains              Instead of finding the tag that predates the commit, find the tag that comes after the commit,
                          and thus contains it

git describe 3cd7388 --> v1.6.3.1-153-g3cd7388
####################################################################################################
###                                SYMBOLIC-REF
####################################################################################################
git symbolic-ref [ref]     Read, modify and delete symbolic refs
                           Given one argument, reads which branch head the given symbolic ref refers to and outputs its
						   path, relative to the .git/ directory
                           Typically you would give HEAD as the <name> argument to see which branch your working tree is on
                           Given two arguments, creates or updates a symbolic ref <name> to point at the given branch <ref>

git symbolic-ref --short    When showing the value of <name> as a symbolic ref, try to shorten the value, e.g. from refs/heads/master to master.
git symbolic-ref --delete   Delete the symbolic ref <name>
git symbolic-ref -m         Update the reflog for <name> with <reason>
----------------------------------------------------------------------------------------------------
-git symbolic-ref HEAD refs/head/<branch>         Set HEAD to point at a particular branch
-current_branch=$(git symbolic-ref --short HEAD)
----------------------------------------------------------------------------------------------------
There are only two valid kinds of symrefs right now:
    .git/HEAD                                   pointing at somewhere under refs/heads/ hierarchy
    .git/refs/remotes/{some remote name}/HEAD   pointing at somewhere under refs/remotes/{the same remote name}/ hierarchy
####################################################################################################
###                                SHORTLOG
####################################################################################################
git shortlog            Summarize git log output
####################################################################################################
###                                RERERE
####################################################################################################
git rerere            Reuse recorded resolution of conflicted merges
                      Rerere stands for "reuse recorded resolution"
                      First it will record how you deal with conflicts
                      Secondly, if there is the exact same conflict, Git will resolve it for you. Just like that

-reuse recorded resolution
-to control merges
-control merge now and then: a merge of master into your own branch, so that without polluting master
 you can see what conflicts are lurking, and figure out whether theyre hard to fix.
-you need at least one of two conditions to be met
    1. The rerere.enabled configuration setting is set to true
    2. Your repo contains a rerere database (you have a .git/rr-cache directory)
####################################################################################################
###                                FOR-EACH-REF
####################################################################################################
git for-each-ref      Output information on each ref
--count=<count>       This option makes it stop after showing that many refs
####################################################################################################
###                                BISECT
####################################################################################################
-git bisect essentially performs a binary search between two given commits and then presents you with a specific commit’s
 details. You first need to give Git a good commit, where you know your functionality was working, and a bad commit.
-To get started, check out the buggy branch and find the good commits. You’ll need to go through your commit history and
 find the commit hash, then check out that specific commit and test your branch. Once you find a good and bad spot to work
 from, you can run a git bisect.
-bisect Binary search through your commit history to help identify as quickly as possible which commit introduced an issue
-git bisect start
-git bisect bad  <HASH>
----------------------------------------------------------------------------------------------------
git bisect              Binary search for defects
----------------------------------------------------------------------------------------------------
-git-prune      Prune all unreachable objects from the object database.
                Users should run git gc, which calls git prune
    --dry-run   Display which files will be removed

-git prune      Deletes all stale remote-tracking branches under <name>. These stale branches have already
                been removed from the remote repository referenced by <name>, but are still
                locally available in “remotes/<name>”

###################################################################################################################################################################
###                                                     VERY LESS USED COMMANDS
###################################################################################################################################################################
annotate            Annotate file lines with commit information. Only diff with git blame is the output
bundle              Move objects and refs by archive
cherry              Find commits yet to be applied to upstream. Determine whether there are commits
                    in <head>..<upstream> that are equivalent to those in the range <limit>..<head>
diff-tree           Compares the content and mode of blobs found via two tree objects
filter-branch       Rewrite branches
get-tar-commit-id   Extract commit ID from an archive created using git-archive
imap-send           Send a collection of patches from stdin to an IMAP folder
mergetool           Run merge conflict resolution tools to resolve merge conflicts
notes               Add or inspect object notes. By default, notes are saved to and read from refs/notes/commits
                    git notes add -m "a note" && cat .git/refs/notes/commits

relink              Hardlink common objects in local repositories
replace             Create, list, delete refs to replace objects
show-branch         Show branches and their commits
stage               Add file contents to the staging area. Synonym for git add
whatchanged         Show logs with difference each commit introducess
unpack-objects      Unpack objects from a packed archive. Read a packed archive (.pack) from the
                    standard input, expanding the objects contained within and writing them into the
                    repository in "loose" (one object per file) format.
-------------------------------------------------------------------------------------------------------
GIT NOTES
   -Git Notes are, in effect, a separate ‘branch’ of the repository (stored at .git/refs/notes
   -They don't show up in the git branch command (that lists .git/refs/heads by default)
   -git notes add -m "ToDo: Fix stuff"
   -git notes add -m "Review-id: 42"
   -https://stackoverflow.com/questions/2683248/can-i-add-metadata-to-git-commits-or-can-i-hide-some-tags-in-gitk
--------------------------------------------------------------------------------------------------------
-git merge-base - Find as good common ancestors as possible for a merge
                  Finds best common ancestor(s) between two commits to use in a three-way merge
---------------------------------------------- MERGE BASE ------------------------------------------------------------------
git show $(git merge-base <branch> master)
   213	7:10	git init repo
   214	7:10	cd repo
   215	7:10	echo 1 >> file ; git add file ; git commit -m "add 1"
   216	7:10	echo 2 >> file ; git add file ; git commit -m "add 2"
   217	7:10	echo 3 >> file ; git add file ; git commit -m "add 3"
   218	7:11	echo 4 >> file ; git add file ; git commit -m "add 4"
   219	7:11	git log --oneline
   220	7:11	git checkout -b my_test_branch cada475
   221	7:12	git checkout master
   222	7:12	git show --summary `git merge-base my_test_branch master`
----------------------------------------------------------------------------------------------------------------------------

############################################################################################################################
###                        TIPS AND TRICKS
############################################################################################################################
-Commit
    -Commit often, but don't push every commit
	-Commits Should be Small and Frequent
	-Each commit must let the branch into a stable state
	-Test Before You Commit
	-Each commit has only one purpose. Keep your commits tight
	-Avoid merge commits
    -Make a commit when you Completed a unit of work or Have changes you may want to undo
	-The commit one-liner --> DO NOT USE git commit -m "some message"
	-Write good commit messages
	-Commit Messages Should be Semantic: Every commit message should describe why the code was changed – or what a change accomplished

-Pull frequently
-Start a new branch named after that feature
-From the master branch you should only branch hotfixes because the master branch should always be the stable version
-Never rewrite shared history
-Write informative README pages

1. Make small changes
2. Don’t commit personal files
3. Update often and right before pushing to avoid merge conflicts
4. Verify your code change before pushing it to a repository; ensure it compiles and tests are passing
5. Pay close attention to commit messages
6. Link code changes to work items

############################################################################################################################
###                  GIT INFO
############################################################################################################################
LINEAR HISTORY:
-A linear history is simply a Git history in which all commits come after one another
-The principle is simple: rebase your branch before you merge it (to have a clean history)
-why linear history
    -Looking at the history
    -Backtracking changes
    -Tracking down bugs
    -Reverting changes
-Benifits
    -very valuable
    -git bisect
    -Documentation for the posterity. A linear history is typically easier to follow
    -Improving code review efficiency and effectiveness
    -When you need to modify the history at a later time
    -Scalability
    -easy backtracking changes
    -easy reverting changes
-every merge commit is a potential source of a non-linear history
-always work on branches (you can create logical commits)
-avoid merge commit with rebase
   1. rebase to squeeze
   2. when two developers are working on a branch. If Dev 1 pushes a change, Dev 2 is unable to push his or her changes until he or she runs git pull. If Dev 2 simply runs git pull, a merge       commit will result. Instead, Dev 2 should run git pull --rebase. This will write Dev 2’s commits on top of the commits made by Dev 1, and importantly, it will not result in a merge       commit.
-The main branch of a project should be a summary at the highest level
---------------------------------------------------------------------------------------------------
-Clean working dir                None of tracked files are modified
-Unmodified files                 Files that haven’t changed since last commit
-Modified files                   Modified since your last commit, but NOT staged yet
-Staged files                     Modified that will be added to the next commit
---------------------------------------------------------------------------------------------------
REBASE HELL
-Rebase hell happens when several commits on your branch edit the same area, and upstream also touched the same area
-If your branch has many commits, and you find yourself in rebase hell, try aborting, squashing, and then rebase.
 Squashing is always a viable way out of rebase hell

########################################################################################
###                              UPDATE BRANCHES
########################################################################################
1. UPDATE FEATURE BRANCH WITH MASTER CONTENT
   -To update your branch to match the latest master
   -This is a major source of NON-LINEAR history

  $ git checkout master               ## Update your local master branch
  $ git fetch -p origin               ## Fetch the remote. -p, --prune option to delete any remote-tracking references that no longer exist in the remote. Commits to master will be stored in a local branch, remotes/origin/master
  $ git merge origin/master           ## Merge the changes from origin/master into your local master branch
  $ git checkout <feature-branch>     ## Check out the branch you want to merge into
  $ git rebase master                 ## Merge your (now updated) master branch into your feature branch to update it with the latest changes from your team.
    push:  $ git push origin <feature-branch>  ## Push your changes
    merge: $ git checkout master
           $ git merge <feature-branch>

-What I like about the rebase, is that the conflicts added by one commit will be resolved in this same commit. On the opposite, the 3-way merge will resolve all the conflicts into the new “merge commit”, mixing all together the conflicts added by the different commits of your feature branch.
-To conclude, I hope I have convinced you that rebasing your branch before merging it, can clear your git history a lot

----------------------------------------------------------------------------------------------
Rule of thumb:
-When pulling changes from origin/develop onto your local develop use rebase.
-When finishing a feature branch merge the changes back to develop.

---------------------------------------------------------------------------------------------
# fetch the changes from the remote
git fetch origin

# show commit logs of changes
git log master..origin/master

# show diffs of changes
git diff master..origin/master

# apply the changes by merge..
git merge origin/master

# .. or just pull the changes
git pull

############################################################################################################################
###                  GIT OBJECTS
############################################################################################################################
======================== BASIC STRUCTURE ========================
===> tree -L 1
|------------------------ FILES --------------------------------------------------------------------------------------------
|-- COMMIT_EDITMSG           Last commits message
|-- FETCH_HEAD               The SHAs of branch/remote heads that were updated during the last git fetch
|-- HEAD                     Symbolic ref pointing to a local branch(current checked out commit). Probably refs/heads/master
|-- ORIG_HEAD                Contains a raw SHA-1 instead of a named reference. Backs up the position of HEAD before a potentially dangerous operation (merge, rebase, etc.).
|-- EDIT_DESCRIPTION         ??
|-- MERGE_MSG                When merging. Merge message (about branches, files, and conflicts)
|-- MERGE_MODE               When merging. Used to communicate constraints that were originally given to git merge to git commit when a merge conflicts (E.g. --no-ff)
|-- MERGE_HEAD               When merging. When doing a merge, this is the SHA of the branch you’re merging from.
|-- CHERRY_PICK_HEAD         The commit that you’re cherry-picking
|-- config                   Contains settings for this repository
|-- description              Description of your project
|-- index                    Index file
|-- packed-refs              ??
|------------------------- DIRECTORIES -------------------------------------------------------------------------------------
|-- branches                 A slightly deprecated way to store shorthands to be used to specify URL to git fetch, git pull and git push commands is to store a file in branches/<name> and give name to these commands in place of repository argument
|-- modules/<name>           Other modules
|-- lost-found               Finds dangling commits and tags from the object database, and creates refs to them in the .git/lost-found/ directory. Commits and tags that dereference to commits are stored in .git/lost-found/commit, and other objects are stored in .git/lost-found/other
|-- hooks                    Store all hooks
|   |-- applypatch-msg
|   |-- commit-msg
|   |-- post-commit
|   |-- post-receive
|   |-- post-update
|   |-- pre-applypatch
|   |-- pre-commit
|   |-- pre-rebase
|   |-- prepare-commit-msg
|   `-- update
|-- info                    Additional information about the repository is recorded in this directory.
|   |-- refs
|   |-- grafts              This file records fake commit ancestry information
|   `-- exclude             stores the exclude pattern list. .gitignore is the per-directory ignore file.
|-- logs                    Reflogs. Records of changes made to refs are stored in this director
|   |-- HEAD
|   `-- refs
|        |-- heads/<name>   Records all changes made to the branch tip named <name>
|        |-- stash          stashes. contains the whole stash. But those references are gone after git stash pop
|        |-- remotes/<name> List the remotes
|        `-- tags/<name>    Records all changes made to the tag named <name>
|-- objects[0-9a-f][0-9a-f] Your objects (commits, trees, blobs, tags). Git’s internal warehouse of blobs, all indexed by SHAs. All objects are store in this folder, using their SHA-1 identifier as filename (the first two characters of the identifier are used as sub-folder).
|   |-- Packs               Packs
|   `-- info                Additional info
`-- refs                    References. Pointers to your branches. The master copy of all refs that live in your repository, be they forvstashes, tags, remote tracking branches, or local branches.
    |-- heads               heads contains files named after branches. Each holds the SHA-1 reference of a commit object. For local branches
    |-- remotes             records tip-of-the-tree commit objects of branches copied from a remote repository. lists all remote repositories that were created with git remote. For tracking branches
    |-- stash               contains the reference of the commit used to create the stash
    `-- tags                tags contains files named after tags. Each contains the SHA-1 reference of a commit object (for simple tags, without annotations).

----------------------------------------------------------------------------------------------------------------------------
INDEX ( DONE )
    -Binary file which can be queried with git ls-files --stage
    -Containing a sorted list of path names, each with permissions and the SHA1 of a blob object
    -The index is one of the most important data structures in git.
    -Also called staging area
    -Mapping of files to the objects in the object store
    -Contains all info to create a commit
    -Example
            $ git ls-files --stage
             100644 96d3d35057c8a07b60b47f06e9d91ac82cdd088c 0   LICENSE
             100644 664991ea874248f4232568b304608679dfa7db42 0   README.md

----------------------------------------------------------------------------------------------------------------------------
-OBJECTS (DONE)
    -Git only knows how to store "objects"
    -Immutable (they are added but not changed) and identified by its unique SHA-1 hash
    -Every object consists of a type, a size and content
    -The Git object model has four object types:
        blob   - stores file content
        tree   - stores directory layouts and filenames
        commit - stores commit info and forms the git commit graph
        tag    - stores annotated tag
    -Stored as objects in .git/objects/
    -Git objects are a zlib compressed binary
    -Created by git-hash-object
    -When Git stores objects, it splits the 40 character hash into two parts:
      1. the first two characters and the last 38.
      2. The first two characters, in this case 25, as the folder, and the last 38, 7cc5642cb1a054f08cc83f2d943e56fd3ebe99, as the file. The purpose of splitting the hash is to make indexing quicker. Some of the original motivations for developing Git was a requirement of speed and performance, can't manage decades of kernel history with a slow tool.

----------------------------------------------------------------------------------------------------------------------------
-BLOB (DONE)
    -Binary Large Object
    -Stores the contents of a file, but doesn't contain metadata
    -Display content of a blob: git show <SHA>
    -Each version of a file is represented by blob
----------------------------------------------------------------------------------------------------------------------------
-TREE (DONE)
    -trees are objects
    -A tree is a list of references to blobs and trees
    -A tree is basically like a directory
    -Trees are objects where the contents of the object describes a folder structure "tree
    -git ls-tree <SHA>
    -The tree object contains one line per file or subdirectory, with each line:
         -file permissions
         -object type  ("blob" for file, "tree" for subdirectory)
         -object hash
         -filename
    -Trees are created using the git-update-index(1) and git-write-tree(1) plumbing commands

    -Since we have an object already added to the Git object store, we can go ahead and create a basic tree:
        ± git update-index --add --cacheinfo 100644 257cc5642cb1a054f08cc83f2d943e56fd3ebe99 foo.txt
        ± git write-tree
        fcf0be4d7e45f0ef9592682ad68e42270b0366b4

    -Since Git trees are actually objects, we can use the git-cat-file command again to print out the contents of the tree
     ± git cat-file -p fcf0be4d7e45f0ef9592682ad68e42270b0366b4
     100644 blob 257cc5642cb1a054f08cc83f2d943e56fd3ebe99    foo.txt

----------------------------------------------------------------------------------------------------------------------------
-COMMIT
    -Git commits are also objects
    -A commit is a reference to a tree, a reference to parent commit
    -Every commit holds a single tree
    -It contains meta-information about that point in time
    -ZLIB compressed blob
    -Created using: git-commit-tree
    -The git-commit-tree command takes a message, a tree, and optionally a parent commit, and creates a commit object
    -If the parent is not specified, it creates a root commit
    -The commit object contains the directory tree object hash, parent commit hash, author, committer, date and message
    -COMMIT OBJECT
     sha1(
         commit message  => "initial commit"
         commiter        => Christoph Burgdorf <christoph.burgdorf@gmail.com>
         commit date     => Sat Nov 8 10:56:57 2014 +0100
         author          => Christoph Burgdorf <christoph.burgdorf@gmail.com>
         author date     => Sat Nov 8 10:56:57 2014 +0100
         tree            => 9c435a86e664be00db0d973e981425e4a3ef3f8d
     )
    -Git stores commits the same way it stores files and trees, as a zLib compressed binary in the .git/objects folders

----------------------------------------------------------------------------------------------------------------------------
-TAG (DONE)
    -A tag is a way to mark a specific commit as special
    -A tag object contains:
        -object name
        -object type
        -tag name
        -the name of the person ("tagger") who created the tag
        -message, which may contain a signature, as can be seen using git cat-file: git cat-file tag v1.5.0
    -Tags are stored in .git/refs/tags
    -All tags live in refs/tags, both the ones you created locally and the ones you fetched from others
    -There are two types of tags: lightweight tags which point directly to a commit, tree or blob, and annotated tags which point to a tag object.
    -A tag object contains a tag message (for example "Version 1.0"), a pointer to a commit, tree or blob, and possibly a GPG signature.
    -Annotated tags should be used for tags you want to share, such as releases
    -Lightweight tags can be used for simple local bookmarks
----------------------------------------------------------------------------------------------------------------------------
-SHA (DONE)
    -40-digit "object name"
    -Technical reference for an object in the Git database
    -The name is calculated by taking the SHA1 hash of the contents of the object
    -echo -n "thoughtram" | openssl sha1      ====> a9eb85ea214a6cfa6882f4be041d5cce7bee3e45
    -A checksum of the content you're storing plus a header
----------------------------------------------------------------------------------------------------------------------------
-REFS (DONE)
    -A reference is simply a file stored somewhere in .git/refs, containing the hash of a commit object.
    -Refs are stored as normal text files in the .git/refs directory
    -The refs/heads/ directory defines all of the local branches in you repository. Each filename matches the name of the corresponding branch, and inside the file you’ll find a commit hash
    -The refs/tags/ directory works the exact same way, but it contains tags instead of branches
    -HEAD: This is a symbolic reference which points to the tip of the current branch rather than an actual commit
    -The reflog is Git’s safety net
    -A ref is an indirect way of referring to a commit
    -A user-friendly alias for a commit hash
    -A ref is anything pointing to a commit, for example, branches (heads), tags, and remote branches
    -Refs are stored as plain text files in the .git/refs/ directory
    -Different types
      -.git/refs/heads/[branch_name]       ## All local branches. Each file contains the commit hash
      -.git/refs/heads/master              ## Pointer to where the current branch is at that point
      -.git/refs/remotes/                  ## lists all remote repositories that you created with git remote as separate subdirectories. Inside each one, you’ll find all the remote branches that have been fetched into your repository
      -.git/refs/remotes/remote-name/HEAD  ## symbolic refs that point to remote-tracking branches
      -.git/refs/tags                      ## contains stages, like heads which contains branches
    -To change the location of the master branch, all Git has to do is change the contents of the refs/heads/master file
    -Creating a new branch is simply a matter of writing a commit hash to a new file
    -There are a few special refs that reside in the top-level .git directory
         HEAD             - Symbolic ref pointing to a local branch(current checked out commit) (ref: refs/heads/branch_vandaag)
         FETCH_HEAD       - The SHAs of branch/remote heads that were updated during the last git fetch
         ORIG_HEAD        - Contains a raw SHA-1 instead of a named reference. Backs up the position of HEAD before a potentially dangerous operation (merge, rebase, etc.).
         MERGE_HEAD       - The commit(s) that you’re merging into the current branch with git merge
         CHERRY_PICK_HEAD - The commit that you’re cherry-picking

----------------------------------------------------------------------
|    Commit-ish/Tree-ish    |                Examples
----------------------------------------------------------------------
|  1. <sha1>                | dae86e1950b1277e545cee180551750029cfe735
|  2. <describeOutput>      | v1.7.4.2-679-g3bee7fb
|  3. <refname>             | master, heads/master, refs/heads/master
|  4. <refname>@{<date>}    | master@{yesterday}, HEAD@{5.minutes.ago}, master@{one.week.ago}
|  5. <refname>@{<n>}       | master@{1}, HEAD@{2}, stash@{0}, branch@{0}
|  6. @{<n>}                | @{1}
|  7. @{-<n>}               | @{-1}
|  8. <refname>@{upstream}  | master@{upstream}, @{u}
|  9. <rev>^                | HEAD^, v1.5.1^0
| 10. <rev>~<n>             | master~3
| 11. <rev>^{<type>}        | v0.99.8^{commit}
| 12. <rev>^{}              | v0.99.8^{}
| 13. <rev>^{/<text>}       | HEAD^{/fix nasty bug}
| 14. :/<text>              | :/fix nasty bug
----------------------------------------------------------------------
|       Tree-ish only       |                Examples
----------------------------------------------------------------------
| 15. <rev>:<path>          | HEAD:README.txt, master:sub-directory/
----------------------------------------------------------------------
|         Tree-ish?         |                Examples
----------------------------------------------------------------------
| 16. :<n>:<path>           | :0:README, :README
----------------------------------------------------------------------
Timed
-1.minute.ago
-1.hour.ago
-1.day.ago
-yesterday
-1.week.ago
-1.month.ago
-1.year.ago
-2011-05-17.09:00:00

-<commit-ish>     Indicates a commit or tag object name
-<tree-ish>       Indicates a tree, commit or tag object name

-"Commit-ish"     Identifiers that ultimately lead to a commit object. For example, tag -> commit
-"Tree-ish"       Identifiers that ultimately lead to tree (i.e. directory) objects. tag -> commit -> project-root-directory

----------------------------------------------------------------------------------------------------------------------------
SYMBOLIC REFS (DONE)
	-Doesn't point to an object directly, points to another reference
	-For instance, .git/HEAD is a symbolic reference. It points to the current branch you are working on
----------------------------------------------------------------------------------------------------------------------------
REFSPECS (DONE)
    -A refspec maps a branch in the local repository to a branch in a remote repository
    -The definition of a refspec is simply a pair of reference names, separated by a colon :, and with an optional leading plus sign +. The reference name on the left of the colon is the source and the name on the right is the destination. If the leading plus sign is present, the refspec says that Git should do a "forced update", i.e., update a reference even if it's not a fast-forward (branch references) or is naturally disallowed (for tags).
    -Refspecs are used for both git fetch and git push. Omitting one of the parts has different effects in the different commands, so it's easiest to work with refspecs that are complete on both sides. When used with git fetch, the source is indeed the server's reference (usually a branch-name, but you may copy tags, notes, or any other reference the server exposesand by default, servers expose everything). The destination is, as you surmised, your own local reference, likewise usually a branch-name.
    -A refspec tells git how to map references from a remote to the local repo

    -A refspec is specified as [+]<src>:<dst>.
         -The <src> parameter is the source branch in the local repository
	     -The <dst> parameter is the destination branch in the remote repository
	     -The optional + sign is for forcing the remote repository to perform a non-fast-forward update
	-E.g.:git push origin :some-feature

===== ADDITING A REMOTE =======
-git remote add origin https://github.com/schacon/simplegit-progit
 ==> this will add in the .git/config file
  [remote "origin"]
  	url = https://github.com/schacon/simplegit-progit
	fetch = +refs/heads/*:refs/remotes/origin/*

==> specifying :
      -the name of the remote (origin),
      -the URL of the remote repository,
      -and the refspec to be used for fetching

===> The format of the refspec is, first, an optional +, followed by <src>:<dst>, where <src> is the pattern for references on the remote side and <dst> is where those references will be tracked locally. The + tells Git to update the reference even if it isnt a fast-forward

===> In the default case that is automatically written by a git remote add command, Git fetches all the references under refs/heads/ on the server and writes them to refs/remotes/origin/ locally
===> So, if there is a master branch on the server, you can access the log of that branch locally via any of the following:
         $ git log origin/master
         $ git log remotes/origin/master
         $ git log refs/remotes/origin/master

-If you want Git instead to pull down only the master branch each time, and not every other branch on the remote server, you can change the fetch line to refer to that branch only
     fetch = +refs/heads/master:refs/remotes/origin/master
 ===> This is just the default refspec for git fetch for that remote

-To pull the master branch on the remote down to origin/mymaster locally, you can run:
   $ git fetch origin master:refs/remotes/origin/mymaster

- If you want to always fetch the master and experiment branches from the origin remote, add two lines:
   [remote "origin"]
	url = https://github.com/schacon/simplegit-progit
	fetch = +refs/heads/master:refs/remotes/origin/master
	fetch = +refs/heads/experiment:refs/remotes/origin/experiment

===== PUSHING REFSPECS ======
-If the QA team wants to push their master branch to qa/master on the remote server, they can run
  $ git push origin master:refs/heads/qa/master

-If they want Git to do that automatically each time they run git push origin, they can add a push value to their config file:
   [remote "origin"]
	url = https://github.com/schacon/simplegit-progit
	fetch = +refs/heads/*:refs/remotes/origin/*
	push = refs/heads/master:refs/heads/qa/master

=====DELETING REFERENCES ======
-You can also use the refspec to delete references from the remote server by running something like this
-  $ git push origin :topic

-Because the refspec is <src>:<dst>, by leaving off the <src> part, this basically says to make the topic branch on the remote nothing, which deletes it.

-OR: $ git push origin --delete topic

----------------------------------------------------------------------------------------------------------------------------
RELATIVE REFS (DONE)
- ~                          Relative references to the parent of a commit.        E.g. 3157e~1 is commit before 3157e
- ^ (at end of reference)    Parent of that commit
-..                          Range specification                                   E.g. git log master..experiment
-...                         Either of the two but not both                        E.g. git log master...experiment

-Since merge commits have more than one parent, there is more than one path that you can follow. For 3-way merges, the first parent is from the branch that you were on when you performed the merge, and the second parent is from the branch that you passed to the git merge command.
-The ~ character will always follow the first parent of a merge commit. If you want to follow a different parent, you need to specify which one with the ^ character
-ref~ is shorthand for ref~1 and means the commit's first parent. ref~2 means the commit's first parent's first parent.
-ref^ is shorthand for ref^1 and means the commit's first parent. But where the two differ is that ref^2 means the commit's second parent (remember, commits can have two parents when they are a merge).
-HEAD^ is shorthand for saying HEAD^1, which literally means show me parent 1 of that commit.

Both ~ and ^ on their own refer to the parent of the commit (~~ and ^^ both refer to the grandparent commit, etc.) But they differ in meaning when they are used with numbers:
    ~2 means up two levels in the hierarchy, via the first parent if a commit has more than one parent
    ^2 means the second parent where a commit has more than one parent (i.e. because it's a merge)

-----------------------------------------------------------------------------------------------------------------------------
git log A..B                      show all of the commits that B has that A doesn't have
git log A...B                     show you both the commits that A has and that B doesn't have, and the commits that B has
                                  that A doesn't have, or in other words, it will filter out all of the commits that both
								  A and B share, thus only showing the commits that they don't both share.
-----------------------------------------------------------------------------------------------------------------------------
git log ..feature       vs    git log master..feature
## which means «all commits reachable from "origin/master" which do not include commits reachable from "master"»
-git log master..origin/master

-git diff A...B     is the same as    git diff $(git merge-base A B) B
-git diff master...HEAD     is the same as     git diff master...

-----------------------------------------------------------------------------------------------------------------------------
-Most refs are a pointer from a name to a commit. There are three exceptions to this rule:
    HEAD (discussed next) is usually a symbolic ref pointing to a local branch
    refs/remotes/remote-name/HEAD are symbolic refs that point to remote-tracking branches
    Tags usually point to tag objects or commits, but it's not unheard of for tags to point to blobs or trees.

-Symbolic refs do not point to an object, but to another ref; similar to how symlinks work
-HEAD: it is the currently checked out commit
-All tags live in refs/tags, both the ones you created locally and the ones you fetched from others.
-The refs under refs/remotes are all copied from your remote repositories when you clone, fetch or push.
-We already know ORIG_HEAD, which gets created by commands that drastically move HEAD,
-----------------------------------------------------------------------------------------------------------------------------
-HEAD (DONE)
    -Plain text file located at .git/HEAD that references a currently checked out commit
    -By default, references the current branch, e.g. master
    -$ cat .git/HEAD
       ref: refs/heads/master
    -In turn, .git/refs/heads/master contains its tip commit’s SHA-1
    -$ git cat-file -p HEAD
     tree 1d2cfad339094df7ecad1e40ed2d6382c97bbb35
     parent 735371120ad60a15ad9d941a58b4f86deca8efa1
     author Maxime <maxime@delicious-insights.com> 1458209018 +0100
     committer Maxime <maxime@delicious-insights.com> 1458212547 +0100
-----------------------------------------------------------------------------------------------------------------------------
-DETACHED HEAD (DONE)
    -Whenever you have checked out a non-referenced head, you end up with a detached head
    -The HEAD usually points to master or some other local branch, but when you check out a previous commit, HEAD no longer
     points to a branch. It points directly to a commit (the commit is likely to be on multiple branches)
    -Normally the HEAD stores the name of a branch.  However, git also allows you to check out an arbitrary commit that
     isn't necessarily the tip of any particular branch.  In this case HEAD is said to be "detached"

-----------------------------------------------------------------------------------------------------------------------------
DANGLING (DONE)
-dangling object   An unreachable object which is not reachable even from other unreachable objects; a dangling object has
                   no references to it from any reference or object in the repository.

-Dangling blob     A change that made it to the staging area/index but never got committed. One thing that is amazing with
                   git is that once it gets added to the staging area, you can always get it back because these blobs
				   behave like commits in that they have a hash too!!
                   Is a file that was not attached to a commit. This is often caused by git adds that were superceded
                   before commit or merge conflicts. Inspect these files with: git show SHA-1

-Dangling commit   A commit that isn't linked to any branch or tag either directly or by any of its ascendants.
                   Commit no longer reachable by any branch or tag.  This can happen due to resets and rebases and
                   are normal. git show SHA-1 will let you inspect them

-A dangling tree is a directory tree of files that was not attached to a commit. These are rarely interesting, and often caused by merge conflicts. Inspect these files with git ls-tree -r SHA-1

-Show dangling stuff  : git fsck
-To show what         : git show [hash]
-Remove dangling stuff: git reflog expire --expire=now --all
                        git gc --prune=now

-unreachable object
    An object which is not reachable from a branch, tag, or any other reference.
-dangling object
    An unreachable object which is not reachable even from other unreachable objects;
    a dangling object has no references to it from any reference or object in the repository.

-feature branch will have an extraneous merge commit every time you need to incorporate upstream changes. If the master is very active this can pollute your feature branch’s history.

###############################################################################################################################################################
-Git has several different methods to find a base commit, these methods are called "merge strategies"
-Once Git finds a common base commit it will create a new "merge commit" that combines the changes of the specified merge commits.
-THIS IS just a regular commit
-The git merge and git pull commands can be passed an -s (strategy) option
-If not explicitly specified, Git will select the most appropriate merge strategy based on the provided branches

1. RECURSIVE
-operates on two heads
-default
-git merge -s recursive branch1 branch2

2. RESOLVE
-only resolve two heads using a 3-way merge algorithm
-git merge -s resolve branch1 branch2

3. OCTOPUS
-default merge strategy for more than two heads
-When more than one branch is passed octopus is automatically engaged
-If a merge has conflicts that need manual resolution octopus will refuse the merge attempt.
-git merge -s octopus branch1 branch2 branch3 branchN

4. OURS
-The Ours strategy operates on multiple N number of branches
-The output merge result is always that of the current branch HEAD
-The "ours" term implies the preference effectively ignoring all changes from all other branches
-git merge -s ours branch1 branch2 branchN

5. SUBTREE
-This is an extension of the recursive strategy. When merging A and B, if B is a child subtree of A, B is first updated to reflect the tree structure of A, This update is also done to the common ancestor tree that is shared between A and B
-git merge -s subtree branchA branchB

TYPES OF GIT MERGE STRATEGIES
1. EXPLICIT MERGES
-default
-the explicit part is that they create a new merge commit
-some people don't want this "noise"

2. IMPLICIT MERGE VIA REBASE OR FAST-FORWARD MERGE
-implicit merges do NOT create a MERGE COMMIT!!!!
-triggered by rebase events or fast-forward merges

3. SQUASH ON MERGE, GENERALLY WITHOUT EXPLICIT MERGE
-another type of implicit merge is a squash
-a squash can be performed during an interactive rebase
-multiple commits into one commit. This commit is then appended to the HEAD of the merge base branch.
-A squash is commonly used to keep a 'clean history' during a merge

RECURSIVE GIT MERGE STRATEGY OPTIONS
1. OURS
-Not to be confused with the Ours merge strategy.
-conflicts to be auto-resolved cleanly by favoring the 'our' version
-Changes from the 'theirs' side are automatically incorporated if they do not conflict.

2. THEIRS
-The opposite of the 'ours' strategy. the "theirs" option favors the foreign merging tree in conflict resolution

3. PATIENCE
-This option spends extra time to avoid mis-merges on unimportant matching lines.
-This options is best used when branches to be merged have extremely diverged.

4. DIFF-ALGORITHMIM
###############################################################################################################################################################

-Git manages your work through 5 major areas
    1. Your working directory
    2. The index, or stage
    3. The (local) repository
    4. The stash
    5. The remote

BRANCHING NAMING CONVENTIONS
    -Use grouping tokens (words) at the beginning of your branch names
    -Define and use short lead tokens to differentiate branches in a way that is meaningful to your workflow
    -Use slashes to separate parts of your branch names
    -Do not use bare numbers as leading parts
    -Avoid long descriptive names for long-lived branches

Use "grouping" tokens in front of your branch names
   -feat      Feature I'm adding or expanding
   -bug       Bug fix or experiment
   -junk      Throwaway branch created to experiment
   ==> git branch --list "test/*"
   ==> git branch --list "*/foo"
-------------------------------------------------------------------------------------------------------------------------------------
-Support branch      used to aid parallel development between team members, ease tracking of features, and to assist in quickly fixing live production problems.
-Feature branches    used when developing a new feature or enhancement which has the potential of a development lifespan longer than a single deployment.
-Bug branches differ from feature branches only semantically. Bug branches will be created when there is a bug on the live site that should be fixed and merged into the next deployment.
-A hotfix branch comes from the need to act immediately upon an undesired state of a live production version.
-------------------------------------------------------------------------------------------------------------------------------------

BRANCHES:
  -Create new branch: creates a new pointer to move around
  -A branch in Git is a lightweight movable pointer to one of these commits. The default branch name in Git is master
  -Branches are pointers to commit metadata objects, all stored in .git/refs/heads
  -When the project begins the first thing to do is to create a release branch for the project. The release branch is created from the master branch
  -For every feature that is built in the application a separate feature branch is created. This ensures that the features can be built independently
  -Master, release, feature branches
  -Types of branches:
      -feature : New feature
      -bugfix  : Changes linked to a known issue
      -hotfix  : Quick fixes to the codebase
  -A Few suggestions for naming feature branches:
      - feature/feature-name
      - feature/feature-area/feature-name
      - bugfix/description
      - hotfix/description
-there are branches and tags, which are typically just references to commits.
-A branch, remote branch or a tag (also called lightweight tag) in Git, is just a pointer to an object, usually a commit object.
-Branches and tags are just references to commits, and master is just a normal branch, so a reference too.

-Directory with first 2 characters of the hash in the objects directory: It makes searching faster
-One of the reasons that git checkout is fast is that it doesn’t actually store any diffs.
-Instead, Git stores the actual, raw, content of every file at each commit, which it uses to calculate diffs on-the-fly
-Git does three things to reduce the space on disk
    1. compresses files before storing them, using zlib.
    2. Git saves disk space is by doing deduplication, a technique to remove redundant data. When creating a new commit, Git SHA-1 hashes the contents of each tracked file within the commit to compare to the hashes of all the objects it already has. If a file’s hash matches an existing object’s hash, Git doesn’t store any new content for that file.
    3. Packfiles
-Hashing functions are designed to avalanche: changing just a single bit in an input to a hashing function should yield a completely different output

ATOMIC : forming a single irreducible unit or component in a larger system
       : Commit each fix or task as a separate change
       : Only commit when a block of work is complete
       : Code Reviews are easier, and easies rollback

STAGING AREA : Split work into separate commits
             : Use git add -p to control which lines you want to commit

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@   PLUMBING EXAMPLE     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
1. $ git init repo1
   Initialized empty Git repository in /home/mitchell/DITISONZIN/repo1/.git/
------------------------------------------------------------------------------------------
2. $ cd repo1/
   $ find .git/objects -type f
   $ echo "line1" >> file1
------------------------------------------------------------------------------------------
3. $ git hash-object -w file1                ## Git creates an object with the name as the hash, compresses our given file and stores it there.
   a29bdeb434d874c9b1d8969c40c42161b03fafdc

OR: $echo 'foo' | git hash-object --stdin    ## this will only create a file, not save it!
    257cc5642cb1a054f08cc83f2d943e56fd3ebe99
------------------------------------------------------------------------------------------
4. $ git cat-file -p a29bdeb434d874c9b1d8969c40c42161b03fafdc
   line1

OR: because we know the objects are zlib compressed, we can use a tool like zlib-flate or similar to peer inside the contents of the files ourselves
    $ cat .git/objects/a2/9bdeb434d874c9b1d8969c40c42161b03fafdc | zlib-flate -uncompress
    blob 6line1
------------------------------------------------------------------------------------------
5. $ find .git/objects -type f
   .git/objects/a2/9bdeb434d874c9b1d8969c40c42161b03fafdc
------------------------------------------------------------------------------------------
5.1 $ cat .git/objects/a2/9bdeb434d874c9b1d8969c40c42161b03fafdc |zlib-flate -uncompress    ---> check this!
    blob line1
------------------------------------------------------------------------------------------
6. $ git update-index --add file1

OR:$ git update-index --add --cacheinfo 100644 a29bdeb434d874c9b1d8969c40c42161b03fafdc file1  --> check this!!
------------------------------------------------------------------------------------------
7. $ git ls-files
   file1
------------------------------------------------------------------------------------------
8. $ git write-tree
   4dac192ba8fb8e6751e14a78154a3019b9026c3e
------------------------------------------------------------------------------------------
9. $ git cat-file -p 4dac192ba8fb8e6751e14a78154a3019b9026c3e
   100644 blob a29bdeb434d874c9b1d8969c40c42161b03fafdc    file1
------------------------------------------------------------------------------------------
9.1 $ git cat-file -t 4dac192ba8fb8e6751e14a78154a3019b9026c3e  tree
------------------------------------------------------------------------------------------
10. $ git log --oneline
    fatal: your current branch 'master' does not have any commits yet
------------------------------------------------------------------------------------------
11. $ echo "my first commit" | git commit-tree 4dac192ba8fb8e6751e14a78154a3019b9026c3e     ## manually make a new commit object
    bd3aec75d3ec7208fcb38710fbebb37b48bbf39c

OR: $ git commit-tree bb2fa < /tmp/message
    bd3aec75d3ec7208fcb38710fbebb37b48bbf39c
------------------------------------------------------------------------------------------
11.1 $ git cat-file -p bd3aec75d3ec7208fcb38710fbebb37b48bbf39c
     tree fcf0be4d7e45f0ef9592682ad68e42270b0366b4    -------> check the output!!!
     author kballou <kballou@devnulllabs.io> 1489182707 -0700
     committer kballou <kballou@devnulllabs.io> 1489182707 -0700
     our first commit

------------------------------------------------------------------------------------------
12. $ git log --oneline
    fatal: your current branch 'master' does not have any commits yet
------------------------------------------------------------------------------------------
13. $ git update-ref refs/heads/master bd3aec75d3ec7208fcb38710fbebb37b48bbf39c      ## update our 'master' branch to point to the new commit we just created

OR: echo bd3aec75d3ec7208fcb38710fbebb37b48bbf39c > .git/refs/heads/master           ## registered the commit as the new head of a branch
------------------------------------------------------------------------------------------
14. $ git log --oneline
    bd3aec7 (HEAD -> master) my first commit

############################################################################################################################
###                                            PACK FILES
############################################################################################################################
----------------------------PACK----------------------
-A collection of objects, individually compressed, with delta compression applied, stored in a single file, with an associated index file.
-Used to reduce the load on mirror systems, backup engines, disk storage, etc.
-A packed archive is an efficient way to transfer a set of objects between two repositories.
-In a packed archive, an object is either stored as a compressed whole or as a difference from some other object. The latter is often called a delta
-The packed archive format (.pack) is designed to be self-contained so that it can be unpacked without any further information.
-A pack index file (.idx) is generated for fast, random access to the objects in the pack.
-Placing both the index file (.idx) and the packed archive (.pack) in the pack/ subdirectory of $GIT_OBJECT_DIRECTORY
-Git has the ability to merge together multiple objects into single files, known as pack files
-These are, in essence, multiple objects stored with an efficient delta compression scheme as a single compressed file
-Pack files are stored in the .git/objects/pack/ directory.
-Git starts off adding all files as non-packed objects, or loose objects
-Each packfile can be independently unpacked from other packfiles
-Stores objects per file under:
    .git/objects/pack/pack-<SHA>.pack
    .git/objects/pack/pack-<SHA>.idx
-The purpose of the index file is really a marker to tell Git that the corresponding object is in this pack file.
-packfiles are usually created the first time you push, pull, fetch, or clone

-Objects in a packfile can either be deltified or non-deltified.
-Deltification means that Git stores only a special diff instead of storing the whole object. Normal diffs reference a base object and describe a series of actions (e.g., insert, delete, or typechange) that should be applied to the base object in order to create the new result. Deltas work similarly, except that they’re not meant to be human-readable (and the actions that they describe are different).
-Deltified objects are easy to spot in the git verify-pack output – they’re the ones with the extra SHA at the end. Instead of storing the entire object, they store a delta object. The SHA at the end tells us the base object
-----------------------------------------------------
-Packfiles are mostly self-contained
-it’s possible to parse a packfile without an index file
-The packfile starts with 12 bytes of meta-information and ends with a 20-byte checksum
-The first four bytes spell “PACK” and the next four bytes contain the version number
-The next four bytes tell us the number of objects contained in the pack
-Therefore, a single packfile cannot contain more than 2^32 objects, although a single repository may contain multiple packfiles.
-The final 20 bytes of the file are a SHA-1 checksum of all the previous data in the file.
-----------------------------------------------------
-The heart of the packfile is a series of data chunks, with some metainformation preceding each one.
-The metainformation is formatted slightly differently depending on whether the data chunk that comes after it is deltified or not. In both cases, they begin by telling us the size of the object that the packfile contains. This size is encoded as a variable-length integer with a special format
-Because the integer has a variable length, the first bit of each byte – also called the MSB, for “most significant bit” - is reserved
-That bit tells us whether the next byte belongs as part of the variable-length integer that we’re decoding. If it’s a 1, we should read the next byte. An easy way to check for this is to check if the byte is less than 128, which is 10000000 in binary
-The very first byte of this integer contains one extra piece of information: the type of the object that follows. There are six defined types, which means that this information fits into three bits, and the three bits after the MSB are used to designate this information:
-10110100:
    -1         MSB is set, so the next byte is part of this number
    -011       This is a BLOB object
    -0100      The first four bits of the number (big endian)
-01010110:
    -0         MSB is not set, so this is the last byte in the number
     -1010110  The next seven bits of the number (big endian)
-for the non-deltified types, the data that follows the metainformation is the zlib-compressed object data, which we can handle just like we handle normal Git objects.

-IDX file – it tells us where each object begins
   -a version 2 index file starts with a header, though the index file header is only eight bytes instead of 12
   -The first four bytes are always 255, 116, 79, 99, which are chosen because the first version of the index file did not have any header information, and these four bytes would be an invalid start to a version 1 index file
   -The next four bytes denote the version number explicitly – in our case, version 2
   -Layer 0: four-byte heaer: 255,116,79,99
   -Layer 1: Cumulative object counts (256 entries * 4 bytes/entry = 1024 bytes)
       -the 17th entry (entry #16) indicates the number of objects whose name begins with '10' or a smaller value
       -the last entry indicates the total number of objects
   -object names are just SHAs, which we usually read in base-16

-------------------------Loose objects--------------------------------------------------------------------------------------
-Git starts off adding all files as non-packed objects, or loose objects
-In fact, each time you do a git add to stage a file, you're creating a new object in the loose objects structure
-Git will run a compression on the loose objects. This is triggered either by a git gc request, or automatically after
 various thresholds have been met. Git will then create the pack file and remove the loose object files

--------------------------- commands ----------------------------------------------------------------------------------------
-git pack-objects   : Create a packed archive of objects. Reads list of objects from the standard input, and writes either one or more packed archives with the specified base-name to disk, or a packed archive to the standard output
-git-unpack-objects : Unpack objects from a packed archive. Read a packed archive (.pack) from the standard input, expanding the objects contained within and writing them into the repository in "loose" (one object per file) format
                        -n  Dry-run
-git repack         : Pack unpacked objects in a repository. to combine all objects that do not currently reside in a "pack", into a pack

-git verify-pack    : Validate packed Git archive files
                    : Reads given idx file for packed Git archive created with the git pack-objects command and verifies idx file and the corresponding pack file
                    : We can see which objects are contained in a pack with

--------------------------- SUPER EXAMPLE ----------------------------------------------------------------------------------------

$ touch empty
$ git add empty
$ git commit -m "Add empty"
$ ls .git/objects/
  2e  41  e6  info  pack
$ ls .git/objects/pack/
$
$ git gc
  Counting objects: 3, done.
  Writing objects: 100% (3/3), done.
  Total 3 (delta 0), reused 0 (delta 0)
$ ls .git/objects/pack/
  pack-c13430adeb8251ac959e0563418bc6c7483c597a.idx
  pack-c13430adeb8251ac959e0563418bc6c7483c597a.pack
$ git ls-tree master
  100644 blob e69de29bb2d1d6434b8b29ae775ad8c2e48c5391    empty
$ git cat-file -t e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
  blob
$ git cat-file -s e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
  0

==> The pack file is actually made up of two entries; the index (.idx) and the pack (.pack) files.
    Whilst the latter stores data, the former stores a table-of-contents list of objects contained within the pack itself:

$ hexdump  .git/objects/pack/pack-c13430adeb8251ac959e0563418bc6c7483c597a.pack
  0000000 4150 4b43 0000 0200 0000 0300 0b9c 9c78
  0000010 cca5 0a41 30c2 4010 7dd1 914e 20bd 9219
  0000020 2331 d888 24a3 29d3 2629 d48c e171 5bed
  0000030 e0cf c3f6 b6fb f889 9904 3003 2be5 8896
  0000040 8495 0222 42c4 9058 0303 bce7 f25c 5d52
  0000050 58f9 cdd3 e577 fda7 6de0 c6ac 7a4d 777f
  0000060 aab5 1e3a 6d4d b594 599f ddc7 a603 9108
  0000070 9128 053f c108 f51d 2610 2c7f 34dc 5ecf
  0000080 cbc6 6ebe 0707 3b72 30a6 9c78 0003 0000
  0000090 0100 02a1 9c78 3433 3030 3133 4851 2dcd
  00000a0 a928 7864 f736 ecd1 174d 39af 777b ae6b
  00000b0 8f2b 71ba 49e8 f04f 0044 b3e0 870f 34c1
  00000c0 ad30 82eb ac51 9e95 6305 8b41 c7c6 3c48
  00000d0 7a59
  00000d2
$ hexdump  .git/objects/pack/pack-c13430adeb8251ac959e0563418bc6c7483c597a.idx
  0000000 74ff 634f 0000 0200 0000 0000 0000 0000
  0000010 0000 0000 0000 0000 0000 0000 0000 0000
  *
  00000c0 0000 0100 0000 0100 0000 0100 0000 0100
  *
  0000100 0000 0100 0000 0100 0000 0100 0000 0200
  0000110 0000 0200 0000 0200 0000 0200 0000 0200
  *
  00003a0 0000 0300 0000 0300 0000 0300 0000 0300
  *
  0000400 0000 0300 0000 0300 c72e 2188 d5bd 71df
  0000410 d7c8 658d 004f 529c 7426 ea14 7c41 c801
  0000420 5a79 b835 35e8 3a11 a585 c1c0 7fc7 fb67
  0000430 9de6 9be2 d1b2 43d6 8b4b ae29 5a77 c2d8
  0000440 8ce4 9153 1b60 7e47 737d fc67 766e 2900
  0000450 0000 0c00 0000 9200 0000 8900 34c1 ad30
  0000460 82eb ac51 9e95 6305 8b41 c7c6 3c48 7a59
  0000470 6437 c95a b3b9 4df6 a574 e934 bb03 427d
  0000480 a111 4918
  0000484

====> you see here the HASH!!!!!
  0000430 e6 9d e2 9b b2 d1 d6 43 4b 8b 29 ae 77 5a d8 c2
  0000440 e4 8c 53 91
====>

$ git verify-pack -v .git/objects/pack/pack-c13430adeb8251ac959e0563418bc6c7483c597a.pack
  2ec78821bdd5df71c8d78d654f009c52267414ea commit 188 125 12
  e69de29bb2d1d6434b8b29ae775ad8c2e48c5391 blob   0 9 137
  417c01c8795a35b8e835113a85a5c0c1c77f67fb tree   33 44 146
  non delta: 3 objects
  .git/objects/pack/pack-c13430adeb8251ac959e0563418bc6c7483c597a.pack: ok
$
====> OUTPUT: SHA-1 type size size-in-packfile offset-in-packfile

----------------------------------------------------------------------------------------------------------------------------
CREATING PACKFILES
-git-pack-objects
-git-gc

-git rev-list --objects --all | head -1 | git pack-objects --stdout | xxd
-git rev-list --objects --all | head -1 | git pack-objects test
----------------------------------------------------------------------------------------------------------------------------

-Unlike loose objects, packfiles can store diffs (deltas) between blob versions, which is specially important since one line changes on large blobs / trees are common

-The .idx file is just an index to speed up lookup: it can be generated at any time from a .pack file with index-pack
-git-pack-objects - Create a packed archive of object
-printf '07cd7fe596afc90d9a2c9f7ae30b6b9e7a7b3760
496d6428b9cf92981dc9495211e6e1120fb6f2ba
e69de29bb2d1d6434b8b29ae775ad8c2e48c5391' \
| git pack-objects --stdout

-git pack-objects a     ## This will generate the .idx .pack pair with names a-<SHA>.{idx,pack}
-git repack
-git hash-object a-f847933433935e81b3fee26eaa6002fdf05ad6a5.pack

#############################################################################################################################
###                                                      EXAMPLE 1
#############################################################################################################################

-git add . && git commit && git log
 commit b82828ed05ef076db09118994c7c036708973b40

-$ git cat-file b82828ed05ef076db09118994c7c036708973b40 -p
 tree 66801fba9ba0350874eb1f64b87b6cdb609da859
 author Jacob Clark <jacob.clark@> 1458348004 +0000
 committer Jacob Clark <jacob.clark@> 1458348004 +0000

 Add README and Docs

-$ git cat-file 66801fba9ba0350874eb1f64b87b6cdb609da859 -p
 100644 blob 557db03de997c86a4a028e1ebd3a1ceb225be238    README.md
 040000 tree 76ebb0f0fd6dfc00be4631fd7019d55536f38ea8    docs

-$ git cat-file 557db03de997c86a4a028e1ebd3a1ceb225be238 -p
 Hello World

-$ cat .git/refs/heads/master
 b82828ed05ef076db09118994c7c036708973b40

-$ git checkout -b hello-moon
 Switched to a new branch 'hello-moon'
 $ cat .git/refs/heads/hello-moon
 b82828ed05ef076db09118994c7c036708973b40

-$ touch hello-moon.txt
 $ git add .
 $ git commit -m 'Add hello moon'
 [hello-moon 683d9df] Add hello moon
  1 file changed, 0 insertions(+), 0 deletions(-)
  create mode 100644 hello-moon.txt

-$ cat .git/refs/heads/hello-moon
 683d9df7e5c7247c4606c86e21c84f89e9a575bb

-$ git cat-file 683d9df7e5c7247c4606c86e21c84f89e9a575bb -p
 tree 0a1b6bbf04e5d9448994cae4b5a2cb7eff14302a
 parent b82828ed05ef076db09118994c7c036708973b40
 author Jacob Clark <jacob.jh.clark@googlemail.com> 1458386031 +0000
 committer Jacob Clark <jacob.jh.clark@googlemail.com> 1458386031 +0000

 Add hello moon

-$ git cat-file b82828ed05ef076db09118994c7c036708973b40 -p
 tree 66801fba9ba0350874eb1f64b87b6cdb609da859
 author Jacob Clark <jacob.jh.clark@googlemail.com> 1458348004 +0000
 committer Jacob Clark <jacob.jh.clark@googlemail.com> 1458348004 +0000

 Add README and Docs

-$ git reset --hard b82828ed05ef076db09118994c7c036708973b40
 HEAD is now at b82828e Add README and Docs

-$ cat .git/refs/heads/hello-moon
 b82828ed05ef076db09118994c7c036708973b40

#############################################################################################################################
###                                                      EXAMPLE 2
#############################################################################################################################

--------------------- PART 1 -----------------------------------
$ echo "An awesome aardvark admires the Alps" > animals.txt
$ git hash-object -w animals.txt
a37f3f668f09c61b7c12e857328f587c311e5d1d

$ find .git/objects -type f
.git/objects/a3/7f3f668f09c61b7c12e857328f587c311e5d1d

$ git cat-file -p a37f3f668f09c61b7c12e857328f587c311e5d1d
An awesome aardvark admires the Alps

$ rm animals.txt
$ git cat-file -p a37f3f668f09c61b7c12e857328f587c311e5d1d > animals.txt
$ cat animals.txt
An awesome aardvark admires the Alps

$ echo "Clueless cuttlefish crowd the curious crab" > c_creatures.txt
$ cp c_creatures.txt sea_creatures.txt
$ git hash-object -w c_creatures.txt
  ce289881a996b911f167be82c87cbfa5c6560653
$ git hash-object -w sea_creatures.txt
  ce289881a996b911f167be82c87cbfa5c6560653
===> Hopefully you see is that Git is only saving the contents of our files – it isn’t saving anything about their filenames

--------------------- PART 2 -----------------------------------
$ git update-index --add animals.txt      ## SAVE A FILE TO THE INDEX

$ git ls-files
  animals.txt

$ git write-tree     ## TAKING A PERMINANT COPY OF THE INDEX
  dc6b8ea09fb7573a335c5fb953b49b85bb6ca985

$ find .git/objects -type f
  .git/objects/a3/7f3f668f09c61b7c12e857328f587c311e5d1d
  .git/objects/b1/3311e04762c322493e8562e6ce145a899ce570
  .git/objects/ce/289881a996b911f167be82c87cbfa5c6560653
  .git/objects/dc/6b8ea09fb7573a335c5fb953b49b85bb6ca985

$ git cat-file -p dc6b8ea09fb7573a335c5fb953b49b85bb6ca985
  100644 blob b13311e04762c322493e8562e6ce145a899ce570    animals.txt
  ==> EXPLANATION:
  -100644 is the file permissions. Git only distinguishes between 644 (non-executable) and 755 (executable).
  -blob is the type of the object (more on that below).
  -b13...570 is the ID of the file contents we saved in part 1.
  -animals.txt is the name of that file.

$ git cat-file -t a37f3f668f09c61b7c12e857328f587c311e5d1d
  blob

$ git cat-file -t dc6b8ea09fb7573a335c5fb953b49b85bb6ca985
  tree

-A blob object stores the contents of a file, but doesn’t know what the file is called
-Now we’re creating tree objects, which know what files are called. A tree can point to a blob to describe the file contents.

-NOW EW ARE GOING TO DO SOMETHING WITH A SUBDIRECTORY

-$ mkdir underwater
 $ echo "Dancing dolphins delight in the Danube" > underwater/d.txt
 $ echo "Electric eels exude exuberance and elegance" > underwater/e.txt

-$ git update-index --add underwater/d.txt      ## ADD TO INDEX
 $ git update-index --add underwater/e.txt      ## ADD TO INDEX

-$ git write-tree                               ## CREATE A TREE
 11e2f923d36175b185cfa9dcc34ea068dc2a363c

-INSPECT OUR NEW TREE
 $ git cat-file -p 11e2f923d36175b185cfa9dcc34ea068dc2a363c
 100644 blob b13311e04762c322493e8562e6ce145a899ce570    animals.txt
 040000 tree 8972388aa2e995eb4fa0247ccc4e69144f7175b9    underwater

-$ git cat-file -p 8972388aa2e995eb4fa0247ccc4e69144f7175b9
 100644 blob cb68066907dd99eb75642bdbd449e1647cc78928    d.txt
 100644 blob 9968b7362a7c97e237c74276d65b68ca20e03c47    e.txt

-Trees and blobs are analogous to the structure of the filesystem – blobs are like files, trees are like directories. A tree can point to blobs or other trees, which correspond to subdirectories

--------------------- PART 3 -----------------------------------
-WE CAN CREATE A COMMIT FROM A TREE
-$ echo "initial commit" | git commit-tree 11e2f923d36175b185cfa9dcc34ea068dc2a363c
   65b080f1fe43e6e39b72dd79bda4953f7213658b

-$ git cat-file -t 65b080f1fe43e6e39b72dd79bda4953f7213658b
   commit

-$ find .git/objects -type f
  .git/objects/11/e2f923d36175b185cfa9dcc34ea068dc2a363c
  .git/objects/65/b080f1fe43e6e39b72dd79bda4953f7213658b
  .git/objects/89/72388aa2e995eb4fa0247ccc4e69144f7175b9
  .git/objects/99/68b7362a7c97e237c74276d65b68ca20e03c47
  .git/objects/a3/7f3f668f09c61b7c12e857328f587c311e5d1d
  .git/objects/b1/3311e04762c322493e8562e6ce145a899ce570
  .git/objects/cb/68066907dd99eb75642bdbd449e1647cc78928
  .git/objects/ce/289881a996b911f167be82c87cbfa5c6560653
  .git/objects/dc/6b8ea09fb7573a335c5fb953b49b85bb6ca985

-$ git cat-file -p 65b080f1fe43e6e39b72dd79bda4953f7213658b
  tree 11e2f923d36175b185cfa9dcc34ea068dc2a363c
  author mitch mitch@bla    1520806168 +0000
  committermitch mitche@bla 1520806168 +0000

  initial commit

-$ git update-index --add c_creatures.txt

 $ git write-tree
   f999222f82d1ffe7233a8d86d72f27d5b92478ac

 $ echo "Adding c_creatures.txt" | git commit-tree f999222f82d1ffe7233a8d86d72f27d5b92478ac -p 65b080f1fe43e6e39b72dd79bda4953f7213658b
   fd9274dbef2276ba8dc501be85a48fbfe6fc3e31

-$ git cat-file -p fd9274dbef2276ba8dc501be85a48fbfe6fc3e31
   tree f999222f82d1ffe7233a8d86d72f27d5b92478ac
   parent 65b080f1fe43e6e39b72dd79bda4953f7213658b

   author mitch mitch@bla    1520806875 +0000
   committermitch mitche@bla 1520806875 +0000

   Adding c_creatures.txt

-Let’s briefly recap: we started with blobs, which contained the contents of a file. Then trees let us hold filenames and directory structure, by referring to blobs and other trees – and thus take snapshots of the state of a repo. Now we have commits, which refer to trees and give them context. Commits can refer to parent commits, which allows us to construct a history

--------------------- PART 4 -----------------------------------
CREATING OUR FIRST BRANCH
-We can use the update-ref command to create a named reference to a commit.
-E.g. git update-ref refs/heads/master fd9274dbef2276ba8dc501be85a48fbfe6fc3e31
-$ find .git/refs -type f
   .git/refs/heads/master
 $ cat .git/refs/heads/master
   fd9274dbef2276ba8dc501be85a48fbfe6fc3e31
-$ git cat-file -p master
   tree f999222f82d1ffe7233a8d86d72f27d5b92478ac
   parent 65b080f1fe43e6e39b72dd79bda4953f7213658b
   author mitch mitch@bla    1520806875 +0000
   committermitch mitche@bla 1520806875 +0000

   Adding c_creatures.txt
-$ git rev-parse master
   fd9274dbef2276ba8dc501be85a48fbfe6fc3e31
====>  A ref in the heads folder is more commonly called a branch!!!

ADDITING COMMITS TO A BRANCH
$ echo "Flying foxes feel fantastic but frightening" > foxes.txt
$ git update-index --add foxes.txt
$ git write-tree
  c08523d153f6415cda07ea27948830407f243a37
$ echo "Add foxes.txt" | git commit-tree c08523d153f6415cda07ea27948830407f243a37 -p master
  b023d92829d5d076dc31de5cca92cf0bd5ae8f8e
$ git log --oneline b023d92829d5d076dc31de5cca92cf0bd5ae8f8e
  b023d92 Add foxes.txt
  fd9274d Adding c_creatures.txt
  65b080f initial commit

$ git log --oneline master
  fd9274d Adding c_creatures.txt
  65b080f initial commit
  ===> THE COMMIT IS NOT ADDED TO THE MASTER BRANCH!!!! YOU SEE!!!
  ===> Unlike in the world of porcelain commands, branches/refs aren’t automatically advanced to point at new commits. If we create new commits, we need to update the ref manually
$ git update-ref refs/heads/master b023d92829d5d076dc31de5cca92cf0bd5ae8f8e
$ git log --oneline master
  b023d92 Add foxes.txt
  fd9274d Adding c_creatures.txt
  65b080f initial commit

WORKING WITH MULTIPLE BRANCHES
-Lets create a second branch:
 $ git update-ref refs/heads/dev 65b080f1fe43e6e39b72dd79bda4953f7213658b
 ==> Now dev is a reference to the initial commit in the repository
 $ find .git/refs -type f
   .git/refs/heads/dev
   .git/refs/heads/master
 $ git branch
     dev
   * master
-The current branch is determined by the contents of the HEAD file
- $ cat .git/HEAD
    ref: refs/heads/master
-We can use symbolic-ref to tell Git we’re on the dev branch instead
-$ git symbolic-ref HEAD refs/heads/dev
 $ git branch
   * dev
     master
- $ git cat-file -p HEAD
    tree 11e2f923d36175b185cfa9dcc34ea068dc2a363c
    author mitch mitch@bla    1520806875 +0000
    committermitch mitche@bla 1520806875 +0000

    initial commit

#############################################################################################################################
###                                                      EXAMPLE 3
#############################################################################################################################
---------------------------------------------------------------------------------------------------------
-$ cat .git/refs/heads/master
 a39b9fdd624c35eee08a36077f411e009da68c2f
---------------------------------------------------------------------------------------------------------
-$ git branch the-ending
 $ git branch
     * master
     the-ending
 --> a new entry must have been added to .git/refs/heads/ and since there is no extra commit, it should point to our first commit as well
 -$ cat .git/refs/heads/the-ending
  a39b9fdd624c35eee08a36077f411e009da68c2f
---------------------------------------------------------------------------------------------------------
---> git add and commit byeworld
    $ git cat-file 0b17be9dbc34c5a5fbb0b94d57680968efd035ca -p
    100644 blob d18affe001488123b496ceb34d8b13b120ab4cb6 byeworld
    100644 blob a0423896973644771497bdc03eb99d5281615b51 helloworld

    $ git cat-file b300387d818adbbd6e7cc14945fdf4c895de6376 -p
    tree 0b17be9dbc34c5a5fbb0b94d57680968efd035ca
    parent a39b9fdd624c35eee08a36077f411e009da68c2f    -------->THIS
    author = <=> 1537770989 +0100
    committer = <=> 1537770989 +0100

    add byeworld

    $ git cat-file d18affe001488123b496ceb34d8b13b120ab4cb6 -p
    Bye world!

    $ cat .git/refs/heads/the-ending
    b300387d818adbbd6e7cc14945fdf4c895de6376   ------> THIS
    ====> THIS are the parent pointers!!!

    $ cat .git/refs/heads/master
    a39b9fdd624c35eee08a36077f411e009da68c2f
-------------------------------------------------------
-Every commit creates 2 objects
   1. The tree
   2. The commit metadata

#############################################################################################################################
###                                                      EXAMPLE 4
#############################################################################################################################

-We have just created a tree, let's see what committing that tree looks like:
    ± echo 'our first commit' | git commit-tree fcf0be4d7e45f0ef9592682ad68e42270b0366b4
    d7ee3cdd8bfcc1b8c3f935302f2d2e78e69e4197
    (Notice, the hash returned here will be different. This hash is dependent on time and the author)
-Now we have 3 objects!
    ± find .git/objects -type f
    .git/objects/d7/ee3cdd8bfcc1b8c3f935302f2d2e78e69e4197
    .git/objects/fc/f0be4d7e45f0ef9592682ad68e42270b0366b4
    .git/objects/25/7cc5642cb1a054f08cc83f2d943e56fd3ebe99
-Similar to trees and files, we can use the git-cat-file command to inspect the newly created commit object:
    ± git cat-file -f d7ee3cdd8bfcc1b8c3f935302f2d2e78e69e4197
    tree fcf0be4d7e45f0ef9592682ad68e42270b0366b4
    author kballou <kballou@devnulllabs.io> 1453219069 -0700
    committer kballou <kballou@devnulllabs.io> 1453219069 -0700

    our first commit
-Breaking down this structure, we have 4 lines:
    -the first line tells which tree this commit is saving. Since a tree already contains the information of all the objects that are currently being tracked, the commit only needs to save the root tree to be able to save all the information for a commit.
    -The second and third line tell us the author and committer
    -Finally, after a blank line, the rest of the file is reserved for the commit message; since "our first commit" message is short, it only takes a single line

-To inform Git that we have created a commit, we need to add some information to a few files
   1.  First, we need create the master reference. We do this by putting the full commit hash into a file called .git/refs/heads/master
       ± echo d7ee3cdd8bfcc1b8c3f935302f2d2e78e69e4197 > .git/refs/heads/master
   2. The next thing we should do is update the .git/HEAD file to point to our new reference:
       ± echo 'ref: refs/heads/master' > .git/HEAD
   OR: Instead of the two commands above, we can use a single invocation of git-update-ref(1) to perform the above
       ± git update-ref refs/heads/master d7ee3cdd8bfcc1b8c3f935302f2d2e78e69e4197
       (Notice, git-update-ref(1) is an idempotent operation, that is, if the reference has already been changed to the current hash, running this command again will yield no change)

LET'S WALK THROUGH THE MOTIONS AGAIN
    ± echo 'bar' > bar.txt
    ± git hash-object -w bar.txt
    5716ca5987cbf97d6bb54920bea6adde242d87e6
    ± git update-index --add --cacheinfo 100644 \
    >   5716ca5987cbf97d6bb54920bea6adde242d87e6 bar.txt
    ± git write-tree
    b98c9a9f9501ddcfcbe02a9de52964ed7dd76d5a

    ---> So far, we have added a new file, bar.txt with the contents of bar
    ---> We have added the file to a new tree
    ---> and we have written the tree to the object store
    ---> Before we commit the new tree, let's perform a quick inspection of the tree

    ± git cat-file -p b98c9a9f9501ddcfcbe02a9de52964ed7dd76d5a
    100644 blob 5716ca5987cbf97d6bb54920bea6adde242d87e6    bar.txt
    100644 blob 257cc5642cb1a054f08cc83f2d943e56fd3ebe99    foo.txt

    ---> An entry for foo.txt is present in this new tree. Git is implicitly tracking previous objects, and carrying them forward, we didn't have to do anything for Git to do this
    ---> the only new objects in the object store so far is the new object for the contents of bar.txt and the object for the new tree
    ± find .git/objects -type f
    .git/objects/b9/8c9a9f9501ddcfcbe02a9de52964ed7dd76d5a
    .git/objects/57/16ca5987cbf97d6bb54920bea6adde242d87e6
    .git/objects/d7/ee3cdd8bfcc1b8c3f935302f2d2e78e69e4197
    .git/objects/fc/f0be4d7e45f0ef9592682ad68e42270b0366b4
    .git/objects/25/7cc5642cb1a054f08cc83f2d943e56fd3ebe99

    ---> Now, we can commit this new tree using the git-commit-tree(1) command
    ± echo 'our second commit' | git commit-tree \
    >   -p d7ee3cdd8bfcc1b8c3f935302f2d2e78e69e4197 \
    >   b98c9a9f9501ddcfcbe02a9de52964ed7dd76d5a
    b7fd7d75c1375858d8f355735a56228b3eb5e813

    ---> Let's inspect this newly minted commit
    ± git cat-file -p b7fd7d75c1375858d8f355735a56228b3eb5e813
    tree b98c9a9f9501ddcfcbe02a9de52964ed7dd76d5a
    parent d7ee3cdd8bfcc1b8c3f935302f2d2e78e69e4197
    author kballou <kballou@devnulllabs.io> 1453229013 -0700
    committer kballou <kballou@devnulllabs.io> 1453229013 -0700

    our second commit

    ---> This commit should look very similar to the previous commit we created. However, here we have a line dedicated to the "parent" commit, which should line up with the commit passed to the -p flag of git-commit-tree(1)
    ---> We can update the master reference, too, with the new hash
    ± git update-ref refs/heads/master b7fd7d75c1375858d8f355735a56228b3eb5e813

    ---> Let's modify foo.txt and create another commit
    ± echo 'foo 2' > foo.txt
    ± git hash-object -w foo.txt
    a3f555b643cbba18c0e69c82d8820c7487cebe15
    ± git update-index -add --cacheinfo 100644 \
    a3f555b643cbba18c0e69c82d8820c7487cebe15 foo.txt
    ± git write-tree
    68b757546e08c1d9033c8802e4de1c0d591d90c8
    ± echo 'our third commit' | git commit-tree \
    >   -p b7fd7d75c1375858d8f355735a56228b3eb5e813 \
    >   68b757546e08c1d9033c8802e4de1c0d591d90c8
    354c7435a9959e662cea02495957daa93d875899
    ± echo 354c7435a9959e662cea02495957daa93d875899 > .git/refs/heads/master
    ----> This final example, we have gone from creating a file, adding the file to a tree, writing the tree, committing the tree, and finally, pushing forward the master reference

    ----> Let's go ahead and inspect the current state of the object store
    ± find .git/objects -type f
    .git/objects/35/4c7435a9959e662cea02495957daa93d875899
    .git/objects/68/b757546e08c1d9033c8802e4de1c0d591d90c8
    .git/objects/a3/f555b643cbba18c0e69c82d8820c7487cebe15
    .git/objects/b7/fd7d75c1375858d8f355735a56228b3eb5e813
    .git/objects/57/16ca5987cbf97d6bb54920bea6adde242d87e6
    .git/objects/b9/8c9a9f9501ddcfcbe02a9de52964ed7dd76d5a
    .git/objects/d7/ee3cdd8bfcc1b8c3f935302f2d2e78e69e4197
    .git/objects/fc/f0be4d7e45f0ef9592682ad68e42270b0366b4
    .git/objects/25/7cc5642cb1a054f08cc83f2d943e56fd3ebe99
    ---> All the trees are still there, and of course the commits are still around. This is because Git stores objects. It does not store computed differences or anything of the sort, it simply stores the objects

    ---> Git simply stores only the objects you ask, it doesn't store the differences between any files, it doesn't track that a file was renamed. Every commit points to the exact version of every file at that point in time.
    ---> if a difference between the working file and the stored version is asked for, it's computed, if a difference between yesterday's version of a file and today's, it's computed.
    ---> If a file was renamed, it can be inferred by a similarity index and computing the difference between Git trees

#############################################################################################################################
###                                                      EXAMPLE 5
#############################################################################################################################
-$ echo 'test content' | git hash-object -w --stdin
 d670460b4b4aece5915caf5c68d12f560a9fe3e4

-$ find .git/objects -type f
 .git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4

-$ git cat-file -p d670460b4b4aece5915caf5c68d12f560a9fe3e4
 test content

-$ echo 'version 1' > test.txt
 $ git hash-object -w test.txt
 83baae61804e65cc73a7201a7252750c76066a30

-$ echo 'version 2' > test.txt
 $ git hash-object -w test.txt
 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a

$ find .git/objects -type f
  .git/objects/1f/7a7a472abf3dd9643fd615f6da379c4acb3e3a
  .git/objects/83/baae61804e65cc73a7201a7252750c76066a30
  .git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4

-At this point, you can delete your local copy of that test.txt file

-$ git cat-file -p 83baae61804e65cc73a7201a7252750c76066a30 > test.txt
 $ cat test.txt
 version 1

-$ git cat-file -p 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a > test.txt
 $ cat test.txt
 version 2

-$ git cat-file -t 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a
 blob

-A single tree object contains one or more entries, each of which is the SHA-1 hash of a blob or subtree with its associated mode, type, and filename

-For example, the most recent tree in a project may look something like this:
  $ git cat-file -p master^{tree}
  100644 blob a906cb2a4a904a152e80877d4088654daad0c859      README
  100644 blob 8f94139338f9404f26296befa88755fc2598c289      Rakefile
  040000 tree 99f1a6d12cb4b6f19c8655fca46c3ecf317074e0      lib

-Git normally creates a tree by taking the state of your staging area or index and writing a series of tree objects from it
-So, to create a tree object, you first have to set up an index by staging some files
-To create an index with a single entry: the first version of your test.txt file : you can use the plumbing command git update-index
-You must pass it the --add option because the file doesn't yet exist in your staging area
-Then, you specify the mode, SHA-1, and filename:
    $ git update-index --add --cacheinfo 100644 \
      83baae61804e65cc73a7201a7252750c76066a30 test.txt
-blob modes can be 100644 (normal file), 100755(executable), 120000(symbolic link)
-Now, you can use git write-tree to write the staging area out to a tree object
-$ git write-tree
 d8329fc1cc938780ffdd9f94e0d364e0ea74f579
 $ git cat-file -p d8329fc1cc938780ffdd9f94e0d364e0ea74f579
 100644 blob 83baae61804e65cc73a7201a7252750c76066a30      test.txt

-verify:
 $ git cat-file -t d8329fc1cc938780ffdd9f94e0d364e0ea74f579
 tree

-You'll now create a new tree with the second version of test.txt and a new file as well:
 $ echo 'new file' > new.txt
 $ git update-index --add --cacheinfo 100644 \
   1f7a7a472abf3dd9643fd615f6da379c4acb3e3a test.txt
 $ git update-index --add new.txt

-Your staging area now has the new version of test.txt as well as the new file new.txt
-Write out that tree (recording the state of the staging area or index to a tree object) and see what it looks like:
 $ git write-tree
 0155eb4229851634a0f03eb265b69f5a2d56f341
 $ git cat-file -p 0155eb4229851634a0f03eb265b69f5a2d56f341
 100644 blob fa49b077972391ad58037050f2a75f74e3671e92      new.txt
 100644 blob 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a      test.txt

-$ git read-tree --prefix=bak d8329fc1cc938780ffdd9f94e0d364e0ea74f579
 $ git write-tree
 3c4e9cd789d88d8d89c1073707c3585e41b0e614
 $ git cat-file -p 3c4e9cd789d88d8d89c1073707c3585e41b0e614
 040000 tree d8329fc1cc938780ffdd9f94e0d364e0ea74f579      bak
 100644 blob fa49b077972391ad58037050f2a75f74e3671e92      new.txt
 100644 blob 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a      test.txt

-To create a commit object, you call commit-tree and specify a single tree SHA-1 and which commit objects, if any, directly preceded it.
-$ echo 'first commit' | git commit-tree d8329f
 fdf4fc3344e67ab068f836878b6c4951e3b15f3d

-$ git cat-file -p fdf4fc3
 tree d8329fc1cc938780ffdd9f94e0d364e0ea74f579
 author Scott Chacon <schacon@gmail.com> 1243040974 -0700
 committer Scott Chacon <schacon@gmail.com> 1243040974 -0700

 first commit

-The format for a commit object is simple: it specifies the top-level tree for the snapshot of the project at that point; the author/committer information (which uses your user.name and user.email configuration settings and a timestamp); a blank line, and then the commit message

-Next, you'll write the other two commit objects, each referencing the commit that came directly before it:
 $ echo 'second commit' | git commit-tree 0155eb -p fdf4fc3
 cac0cab538b970a37ea1e769cbbde608743bc96d
 $ echo 'third commit'  | git commit-tree 3c4e9c -p cac0cab
 1a410efbd13591db07496601ebc7a059dd55cfe9

-$ git log --stat 1a410e

-This is essentially what Git does when you run the git add and git commit commands??it stores blobs for the files that have changed, updates the index, writes out trees, and writes commit objects that reference the top-level trees and the commits that came immediately before them.

-$ find .git/objects -type f
 .git/objects/01/55eb4229851634a0f03eb265b69f5a2d56f341 # tree 2
 .git/objects/1a/410efbd13591db07496601ebc7a059dd55cfe9 # commit 3
 .git/objects/1f/7a7a472abf3dd9643fd615f6da379c4acb3e3a # test.txt v2
 .git/objects/3c/4e9cd789d88d8d89c1073707c3585e41b0e614 # tree 3
 .git/objects/83/baae61804e65cc73a7201a7252750c76066a30 # test.txt v1
 .git/objects/ca/c0cab538b970a37ea1e769cbbde608743bc96d # commit 2
 .git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4 # 'test content'
 .git/objects/d8/329fc1cc938780ffdd9f94e0d364e0ea74f579 # tree 1
 .git/objects/fa/49b077972391ad58037050f2a75f74e3671e92 # new.txt
 .git/objects/fd/f4fc3344e67ab068f836878b6c4951e3b15f3d # commit 1

-To create a new reference that will help you remember where your latest commit is, you can technically do something as simple as this

  $ echo 1a410efbd13591db07496601ebc7a059dd55cfe9 > .git/refs/heads/master

-$ git log --pretty=oneline master
 1a410efbd13591db07496601ebc7a059dd55cfe9 third commit
 cac0cab538b970a37ea1e769cbbde608743bc96d second commit
 fdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit

 =====> safer way: git update-ref refs/heads/master 1a410efbd13591db07496601ebc7a059dd55cfe9

-$ git update-ref refs/heads/test cac0ca
 $ git log --pretty=oneline test
   cac0cab538b970a37ea1e769cbbde608743bc96d second commit
   fdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit

-The HEAD file is a symbolic reference to the branch youre currently on.
-By symbolic reference, we mean that unlike a normal reference, it doesnt generally contain a SHA-1 value but rather a pointer to another reference.

-$ cat .git/HEAD
 ref: refs/heads/master
 git checkout test
 $ cat .git/HEAD
 ref: refs/heads/test

-$ git symbolic-ref HEAD
 refs/heads/master

-You can also set the value of HEAD using the same command
 $ git symbolic-ref HEAD refs/heads/test
 $ cat .git/HEAD
 ref: refs/heads/test

-You can't set a symbolic reference outside of the refs style
 $ git symbolic-ref HEAD test
 fatal: Refusing to point HEAD outside of refs/

-tag object generally points to a commit rather than a tree
-It's like a branch reference, but it never moves?
-You can make a lightweight tag by running something like this:
-git update-ref refs/tags/v1.0 cac0cab538b970a37ea1e769cbbde608743bc96d   ## lightweighted tag

-If you create an annotated tag, Git creates a tag object and then writes a reference to point to it rather than directly to the commit. You can see this by creating an annotated tag (using the -a option):
 git tag -a v1.1 1a410efbd13591db07496601ebc7a059dd55cfe9 -m 'test tag'

-$ cat .git/refs/tags/v1.1
 9585191f37f7b0fb9444f35a9bf50de191beadc2

-$ git cat-file -p 9585191f37f7b0fb9444f35a9bf50de191beadc2
 object 1a410efbd13591db07496601ebc7a059dd55cfe9
 type commit
 tag v1.1
 tagger Scott Chacon <schacon@gmail.com> Sat May 23 16:48:58 2009 -0700

 test tag

-Git stores the value you last pushed to that remote for each branch in the refs/remotes directory
-you can add a remote called origin and push your master branch to it
-$ git remote add origin git@github.com:schacon/simplegit-progit.git
 $ git push origin master
 Counting objects: 11, done.
 Compressing objects: 100% (5/5), done.
 Writing objects: 100% (7/7), 716 bytes, done.
 Total 7 (delta 2), reused 4 (delta 1)
 To git@github.com:schacon/simplegit-progit.git
   a11bef0..ca82a6d  master -> master

==> Then, you can see what the master branch on the origin remote was the last time you communicated with the server, by checking the refs/remotes/origin/master file
==> $ cat .git/refs/remotes/origin/master
    ca82a6dff817ec66f44342007202690a93763949

-Remote references differ from branches (refs/heads references) mainly in that they're considered read-only

#############################################################################################################################
###                                                      EXAMPLE 6
#############################################################################################################################
sudo add-apt-repository ppa:git-core/ppa
sudo apt-get update
sudo apt-get install git

git config --system # => /etc/gitconfig
git config --global # => ~/.gitconfig or ~/.config/git/config
git config --local # => .git/config

#############################################################################################################################
###                                                      EXAMPLE 7
#############################################################################################################################

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! THEORY !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
The git object database
-use a plumping command to see .git/objects

-git hash-object -w <path>      # add a file to the Git object store
-git cat-file -p <hash>         # show the contents of something in the Git object store

-git update-index --add <path>  # add a file to the Git index
-git ls-files                   # list the files in the current index
-git write-tree                 # create a new tree object; write the current index to a tree
-git cat-file -p <hash>         # show the contents of something in the Git object store

-echo "my first commit" | git commit-tree <tree>          # create a Git commit from a tree
git "another commit" | git commit-tree <tree> -p <commit> # create a Git commit from a tree, with another commit as its parent

-git update-ref refs/heads/<branch> <commit>   # create a Git branch which points at the given commit
-git log <branch>                              # show all the commits/history on this branch
-git branch                                    # list all the branches in a repository
-git symbolic-ref HEAD refs/head/<branch>      # set HEAD to point at a particular branch
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! PRACTICAL !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
~/DITISONZIN $ git init repo1
Initialized empty Git repository in /home/mitchell/DITISONZIN/repo1/.git/
~/DITISONZIN $ cd repo1/
total 0
~/DITISONZIN/repo1 $
~/DITISONZIN/repo1 $
~/DITISONZIN/repo1 $
~/DITISONZIN/repo1 $ find .git/objects -type f
~/DITISONZIN/repo1 $ echo "line1" >> file1
~/DITISONZIN/repo1 $ git hash-object -w file1
a29bdeb434d874c9b1d8969c40c42161b03fafdc
~/DITISONZIN/repo1 $ git cat-file -p a29bdeb434d874c9b1d8969c40c42161b03fafdc
line1
~/DITISONZIN/repo1 $ find .git/objects -type f
.git/objects/a2/9bdeb434d874c9b1d8969c40c42161b03fafdc
~/DITISONZIN/repo1 $ git update-index --add file1
~/DITISONZIN/repo1 $ git ls-files
file1
~/DITISONZIN/repo1 $ git write-tree
4dac192ba8fb8e6751e14a78154a3019b9026c3e
~/DITISONZIN/repo1 $ git cat-file -p 4dac192ba8fb8e6751e14a78154a3019b9026c3e
100644 blob a29bdeb434d874c9b1d8969c40c42161b03fafdc    file1
~/DITISONZIN/repo1 $ git log --oneline
fatal: your current branch 'master' does not have any commits yet
~/DITISONZIN/repo1 $ echo "my first commit" | git commit-tree 4dac192ba8fb8e6751e14a78154a3019b9026c3e
bd3aec75d3ec7208fcb38710fbebb37b48bbf39c
~/DITISONZIN/repo1 $ git log --oneline
fatal: your current branch 'master' does not have any commits yet
~/DITISONZIN/repo1 $ git update-ref refs/heads/master bd3aec75d3ec7208fcb38710fbebb37b48bbf39c
~/DITISONZIN/repo1 (master) $ git log --oneline
bd3aec7 (HEAD -> master) my first commit
~/DITISONZIN/repo1 (master) $

############################################################################################################################
###               SCRIPTING
############################################################################################################################
GITROOT=$(git rev-parse --show-toplevel 2> /dev/null)
UPSTREAM1 = $(git rev-parse --symbolic-full-name --abbrev-ref HEAD@{upstream})
UPSTREAM1 = $(git for-each-ref --format='%(upstream:short)' $(git symbolic-ref -q HEAD))

---------------------------------------------------------------------------
    c     = commit
    cam   = commit --amend
    camm  = commit --amend --no-edit
---------------------------------------------------------------------------
    co  = checkout
    cob = checkout -b
    cm  = checkout master
---------------------------------------------------------------------------
    s = status --short --branch
---------------------------------------------------------------------------
    stash-unapply  = !git stash show -p | git apply --reverse
---------------------------------------------------------------------------
    pom          ## push origin master
    publish      ## Push and track the current branch to the remote
    unpublish    ## Delete remote version of current branch
    incoming     ## what is remote and not on the local
    unpushed     ## what is local and not on the remote
    update-from  ## Run git update-from <remote> <branch-name>
---------------------------------------------------------------------------
    d    = diff
    ds   = diff --staged

    dt   = difftool
    dts  = difftool --staged

    dr    = diff --word-diff-regex=.
    drs   = diff --word-diff-regex=. --staged

    d1 = diff HEAD~
    d2 = diff HEAD~~
    d3 = diff HEAD~~~
    d4 = diff HEAD~~~~

    ## Compare commits in one branch against another
    ## E.g.: git diff-branch master develop
    diff-branch = "!f() { git log --oneline $1..$2;  }; f"
---------------------------------------------------------------------------
    branch-name   = rev-parse --abbrev-ref HEAD
    branch-rebase =  "!git rebase -i $(git merge-base master HEAD)"
    branch-reset  =  "!git reset $(git merge-base master HEAD)"
    branch-files  =  "!git diff --name-only $(git merge-base HEAD ${1:-master})"
    branch-diff   =  "!git diff $(git merge-base master HEAD)"
    branch-log    =  "!git log --graph --date=relative master..$(git rev-parse --abbrev-ref HEAD)"

    branch-delete   ## Remove branches that have already been merged with master
    branch-new      ## Create new branch based off origin/master and checkout into the given name
    branch-from     ## Where is the current branch branched from
    lbs             ## lbs = List local branches sorted
    rbs             ## rbs = List remote branches sorted
---------------------------------------------------------------------------
    today           ## Personal log of today
    yesterday       ## Personal log of yesterday
    standup         ## For standup @ work
    log-me          ## Personal log
---------------------------------------------------------------------------
    merge-test      ## Test if auto merge is possible (execute from master)
    edit-unmerged = "!f() { git ls-files --unmerged | cut -f2 | sort -u ; }; vim `f`"
    add-unmerged  = "!f() { git ls-files --unmerged | cut -f2 | sort -u ; }; git add `f`"
---------------------------------------------------------------------------
    log-count-per-hour
    log-count-per-day
    log-count-per-week
    log-count-per-month
    log-count-per-year
    log-count-per-hour-of-day
    log-count-per-day-of-week
    log-count-per-week-of-year
---------------------------------------------------------------------------
    churn          ## "frequency of change" file. Count the number of commits
    contri         ## List contributors with number of commits
    list-objects   ## List all blobs by size in bytes
    count          ## Count number of commits
---------------------------------------------------------------------------
    nevermind      ## reset
    wipe           ## reset with savepoint
---------------------------------------------------------------------------
    fb             ## Find branches containing commit
    ft             ## Find tags containing commit
    fs             ## Find commits by source code
    fm             ## Find commits by commit message
---------------------------------------------------------------------------
    lasttag        ## Last tag in the current branch
    lasttagged     ## Latest annotated tag in all branches
    taglist1       ## List annotated
    taglist2       ## List annotated
    whattag        ## what tag contains the sha: git whatrelease [hash]
    retag          ## Remove the old tag with this name and tag the latest commit with it
---------------------------------------------------------------------------
    unmerged    = !git ls-files --unmerged | cut -f2 | uniq
    untracked   = ls-files --other --exclude-standard
    staged      = ls-files --cached
    modified    = ls-files --modified
    deleted     = ls-files --deleted
    ignored     = ls-files -o -i --exclude-standard
---------------------------------------------------------------------------
    vum  = !${EDITOR:-vim} -p $(git unmerged)
    vmo  = !${EDITOR:-vim} -p $(git modified)
    vut  = !${EDITOR:-vim} -p $(git untracked)
    vall = !${EDITOR:-vim} -p $(git status --porcelain | awk '{print $2}')
---------------------------------------------------------------------------
    assume      = update-index --assume-unchanged
    unassume    = update-index --no-assume-unchanged
    assumed     = !git ls-files -v | grep ^h | cut -c 3-
    unassumeall = !git assumed | xargs git update-index --no-assume-unchanged
    assumeall   = !git s -s | awk {'print $2'} | xargs git assume
---------------------------------------------------------------------------
    logvim      ## Vim log
    log1        ## log level 1
    log2        ## log level 2
    log3        ## log level 3
    lol
---------------------------------------------------------------------------
    whois   ## Given a string for an author
    export  ## Save a repo as a tarball
    who     ## Tells you who the authors are: git who -- path/to/file
    lost
    browse  ## Open the git repo location in your web browser
---------------------------------------------------------------------------
    prune-all       ## Prune all


